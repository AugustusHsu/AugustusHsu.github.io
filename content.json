{"pages":[{"title":"about","text":"Strike the iron while it is hot.","link":"/about/index.html"}],"posts":[{"title":"DL Machine系列-00 環境建置","text":"前言有鑒於每次實驗架設環境都花很多時間，也常常遇到版本更新後某些套件不相容的問題，所以才打算使用Docker來架設深度學習的虛擬環境(絕對不是因為覺得用Docker很帥才用的)，說到深度學習就不得不使用GPU，使用GPU就不得不用nvidia-docker來架設環境，剛剛好本人的實驗室目前有一台電腦正空閒下來，也剛剛好多出一張RTX 2070S，想說利用Docker來一勞永逸這個問題，也順便試試看多GPU的環境是什麼樣的感覺。 電腦配置CPU： AMD Ryen Threadripper 1900X 8-coreMotherBoard：ROG Strix X399-E GammingGPU：RTX 2070 super, GTX 1050RAM：Kingston 16Gx8 2933MHzStorage：2TB SSD2, 1\\1TB m.2 SSDPower：750w金牌電源 Ubuntu 18.04安裝在安裝Ubuntu的時候，會顯示出 install ubuntu/ try ubuntu without installationinstall ubuntu 等等的選項，但是選擇後螢幕變黑屏沒反應。 經過查找，應該是因為Ubuntu對於RTX顯示卡沒有對應的Driver，所以導致這個問題。 我這邊使用另一張顯卡安裝，再去更新Nvidia-driver來避免這個問題。 安裝的時候選擇： 在新安裝的Ubuntu上使用LVM 這是因為之後新增硬碟用LVM來管理。 確認GPU狀態執行ubuntu-drivers devices去確認 如果你只有看到這一項：nvidia-driver-390 - distro non-free，那你必須去將NVIDIA repository加入到你的apt庫。 可以用dpkg -l 'nvidia*'去看電腦上安裝的Nvidia Driver 執行sudo ubuntu-drivers autoinstall安裝driver，完成之後執行nvidia-smi就可以看到： 安裝基本工具1sudo apt-get update2sudo apt-get upgrade3sudo apt-get install vim #好用的編輯器4sudo apt-get install net-tools curl #用來看網路介面卡5sudo apt-get install gparted #硬碟管理工具 設定ip(區域網路)打開/etc/netplan/01-network-manager-all.yaml更改成這樣： 1# Let NetworkManager manage all devices on this system2network:3 version: 24 # renderer: NetworkManager5 eno1:6 addresses: [192.168.123.111/24]7 gateway4: 192.168.111.18 nameservers:9 addresses: [8.8.8.8,8.8.4.4] 參數說明：eno1： 網卡名稱(可以透過ifconfig查看)addresses： 要指定的ipgateway4： 閘道 ip4(gateway6 閘道 ip6)nameservers： dns 以逗號階隔註：/32 指的是 network mask of 255.255.255.255/24 指的是 network mask of 255.255.255.0 依照個人網路調整即可，用sudo netplan apply就可以套用剛剛的設定了。 安裝vnc遠端操控安裝 xfce4 與 xrdp 1sudo apt-get install xfce42sudo apt-get install xrdp 配置登入環境 1echo xfce4-session &gt; ~/.xsession2sudo vim /etc/xrdp/startwm.sh 將stratum.sh更改： 1if test -r /etc/profile; then2 . /etc/profile3fi45test -x /etc/X11/Xsession &amp;&amp; exec /etc/X11/Xsession6-exec /bin/sh /etc/X11/Xsession7+startxfce4 啟動 xrdp 服務： 1sudo service xrdp restart 確認服務正常運行： 1netstat -na | grep 3389 這時就可以透過Windows的遠端桌面連線到你的Linux主機了： 補充可以透過： 1sudo lshw -html &gt; ~/hardware.html 來看這台電腦的硬體配備，用瀏覽器打開即可。","link":"/2019/12/17/DeepLearning-00/"},{"title":"DL Machine系列-01 安裝Docker-19.03+Nvidia-docker","text":"docker安裝sudo apt-get remove docker docker-engine docker.io用來確保你的環境中沒有docker免得版本衝突，可以點這個網站下載和你作業系統相符的docker安裝檔案。我這邊下載的是19.03.5版本。 接著解壓縮跟copy到bin目錄： 1tar xzvf docker-19.03.5.tgz2sudo cp -rf docker/* /usr/local/bin/ 可以透過執行： 1docker --version2sudo docker run hello-world 來確定版本跟能否順利執行。 Nvidia Docker 確認docker版本在19.03以上 linux kernel版本大於3.10(可以透過uname -r確認) 你主機板上裝的GPU架構要在Fermi(2.1)以上(可以上Wiki查看) 還有GPU的Driver要361.93以上(可以用nvidia-smi在終端機查看) 將nvidia的資料庫加到電腦中： 1curl -s -L https://nvidia.github.io/nvidia-docker/gpgkey | \\2 sudo apt-key add -3distribution=$(. /etc/os-release;echo $ID$VERSION_ID)4curl -s -L https://nvidia.github.io/nvidia-docker/$distribution/nvidia-docker.list | \\5 sudo tee /etc/apt/sources.list.d/nvidia-docker.list6sudo apt-get update 安裝nvidia-container-toolkit： 1sudo apt-get install -y nvidia-container-toolkit 參考資料：nvidia-docker的wiki bug1-docker路徑問題因為前面安裝docker是用手動安裝的，所以docker的位置跟用sudo apt-get install docker的位置不一樣，所以有以下錯誤碼： 1Cannot connect to the Docker daemon at unix:///var/run/docker.sock. Is the docker daemon running? 接著我嘗試重新啟動docker： 1sudo systemctl restart docker2# 以下為output3Job for docker.service failed because the control process exited with error code. See \"systemctl status docker.service\" and \"journalctl -xe\" for details 要你執行systemctl status docker.service和journalctl -xe找詳細資料: 1sudo systemctl status docker.service2# 以下為output3docker.service - LSB: Create lightweight, portable, self-sufficient containers.4 Loaded: loaded (/etc/init.d/docker; generated)5 Active: failed (Result: exit-code) since Mon 2019-12-16 23:47:44 CST; 20min ago6 Docs: man:systemd-sysv-generator(8)7812月 16 23:47:44 mars systemd[1]: Starting LSB: Create lightweight, portable, self-sufficient containers....912月 16 23:47:44 mars docker[7032]: * /usr/bin/dockerd not present or not executable1012月 16 23:47:44 mars systemd[1]: docker.service: Control process exited, code=exited status=11112月 16 23:47:44 mars systemd[1]: docker.service: Failed with result 'exit-code'.1212月 16 23:47:44 mars systemd[1]: Failed to start LSB: Create lightweight, portable, self-sufficient containers.. 看到/usr/bin/dockerd，因為安裝的時候dockerd是放在/usr/local/bin/裡面，因此要更改docker.service中的設定，前往/etc/init.d/，編輯docker: 1cd /etc/init.d/2vim docker 將檔案中DOCKERD的位置改成上面手動安裝的位置： 1-DOCKERD=/usr/bin/dockerd2+DOCKERD=/usr/local/bin/dockerd 接著重啟daemon和docker.service，然後查看docker.service： 1systemctl daemon-reload &amp;&amp; systemctl restart docker.service2sudo systemctl status docker.service3# 以下為output4docker.service - LSB: Create lightweight, portable, self-sufficient containers.5 Loaded: loaded (/etc/init.d/docker; generated)6 Active: active (running) since Tue 2019-12-17 00:08:53 CST; 2s ago7 Docs: man:systemd-sysv-generator(8)8 Process: 7724 ExecStart=/etc/init.d/docker start (code=exited, status=0/SUCCESS)9 Tasks: 23 (limit: 19660)10 CGroup: /system.slice/docker.service11 └─7736 /usr/local/bin/dockerd -p /var/run/docker.pid121312月 17 00:08:53 mars systemd[1]: Starting LSB: Create lightweight, portable, self-sufficient containers....1412月 17 00:08:53 mars docker[7724]: * Starting Docker: docker1512月 17 00:08:53 mars docker[7724]: ...done.1612月 17 00:08:53 mars systemd[1]: Started LSB: Create lightweight, portable, self-sufficient containers.. 可以看到可以成功執行了～～ 接著試試看nvidia-docker： 1# Starting a GPU enabled container2$ docker run --gpus all nvidia/cuda nvidia-smi34# Start a GPU enabled container on two GPUs5$ docker run --gpus 2 nvidia/cuda nvidia-smi67# Starting a GPU enabled container on specific GPUs8$ docker run --gpus device=1,2 nvidia/cuda nvidia-smi9$ docker run --gpus device=UUID-ABCDEF,1 nvidia/cuda nvidia-smi1011# Specifying a capability (graphics, compute, ...) for my container12# Note this is rarely if ever used this way13$ docker run --gpus all,capabilities=utilities nvidia/cuda nvidia-smi 如果成功會跟你在電腦中執行nvidia-smi的結果一樣。 因為docker-19.03已經支援使用NVIDIA GPUs作為運行中的設備了。 上面指令有加上--gpu的選項，如果你不要加，可以在Dockerfile上加上： 1# 用來指定使用的gpu，和上面的--gpu相同功能2ENV NVIDIA_VISIBLE_DEVICES all3# 用來指定計算資源，跟上面寫的一樣，這個功能很少用到4ENV NVIDIA_DRIVER_CAPABILITIES compute,utility bug2-container無法stop, kill只能使用sudo systemctl restart docker來重新啟動docker，這是因為原本我安裝的是19.03.1版本，這版本有無法刪除container的問題，在網路上搜索一段時間後，有一些人也有遇到這個問題，不過是在windows版本上。 簡而言之就是因為一些deadlock導致容器的API沒有任何回應，也就是無法stop,kill的問題。 後來在github上看到有人說19.03.5也就是最新版本，解決了deadlocks的問題，果斷更新，更換/usr/local/內所有從docker-19.03.1.tgz解壓縮的檔案，再重開機就沒有這個問題了。","link":"/2019/12/18/DeepLearning-01/"},{"title":"DL Machine系列-02 建立LVM管理儲存空間","text":"前言這台硬碟上裝了5顆硬碟(2顆2.5’ SSD、2顆3.5’ HDD、1顆m.2 SSD)，因為我們實驗室處理的資料量都頗大，動不動就500GB-1TB，如果單純地根據硬碟分開儲存的話，可能會浪費很多剩餘空間，而且在跑資料的時候可能會產生其他資料，這又導致不能預先切割硬碟來符合檔案大小(而且很麻煩)，為了方便合理的利用所有硬碟空間，我決定將硬碟整合起來一起管理。 在找合適的硬碟管理方法的時候，有想過組一個RAID 0的磁碟陣列，不過考慮到之後的擴充需求加上實驗室已經有一台NAS來儲存資料，不需要太擔心資料的完整性，所以查到了LVM的方法來管理資料儲存。 LVM介紹LVM是 Logical Volume Manager(邏輯卷管理)的簡寫，LVM會將一個或多個硬碟的分區在邏輯上集合，可以直接把它當作一顆大硬碟來用，當硬碟空間不足的時候，可以從剩餘空間上劃分一些空間給其他空間不夠的分區使用。 簡單地以一張圖來表示： 不過我這邊只是打算單純地以SSD和HDD兩種不同的硬碟來組成LVM，分別管理讀寫速率不一樣的兩種硬碟。 名詞介紹PV：Physical Volume，物理的磁碟分區，也就是硬碟上的分區，分區要變成PV後，LVM才能利用那個分區。 VG：Volume Group，將所有PV加入VG整合起來，可以理解成一個倉庫或是幾個大的硬碟。 LV：Logical Volume，從VG中劃分空間分配給LV，會建立一個裝置代號放在系統中，即最後被掛載道系統的分區。 經過PV、VG規劃後，可以理解成，把分區整合成一個大的硬碟，再利用這顆硬碟來分割分區或是格式化，不過這顆大硬碟可以增加或是減少分區的容量，而且原本的資料不會受到影響。 LVM建立流程 建立硬碟分區，這裏因為只是想要單純的分成SSD和HDD，所以就直接把整顆硬碟當作一顆分區來建立，格式化的時候記得使用lvm2的格式(在fdisk中編號為8e)。 創建VG，將前面所創立的PV加入到VG中，VG命名建議以vg開頭，這樣容易辨識出這是一個VG。 創建LV，直接設定容量到你要創建的空間，再掛載到系統就行了。 簡單的三個步驟就可以完成創建LVM了，下面以圖示來說明： [實作]LVM硬碟整合先用之前裝過的Gparted把要加入的硬碟全部格式化為lvm2 pv，如果是新硬碟記得要先新增分割表。 另外記得選擇完後Gparted還不會幫你格式化，要記得點選上面的綠色勾勾，才會應用你的配置。 接下來建立VG，這裡我們直接把HDD跟SSD兩個VG創建出來： 1sudo vgcreate vgHDD /dev/sda1 /dev/sdb12sudo vgcreate vgSSD /dev/sda1 /dev/sdb1 這樣我們就創立好兩個VG了，如果要添加新的PV可以使用： 1sudo vgextend YourVG /dev/NewPVDisk 對VG來切割LV出來，這邊使用所有空間，然後用lvdisplay來查看資訊： 1sudo lvcreate -l 100%FREE -n HDD vgHDD2sudo lvcreate -l 100%FREE -n SSD vgSSD3sudo lvdisplay4# output15LV Path /dev/vgHDD/HDD6LV Name HDD7VG Name vgHDD8# output29LV Path /dev/vgSSD/SSD10LV Name SSD11VG Name vgSSD 格式化HDD這個LV，再掛載到需要的位置，這邊用mkfs用xfs的格式來格式化硬碟，要使用mkfs.xfs要記得先安裝xfsprogs： 1sudo apt-get install xfsprogs2sudo mkfs.xfs /dev/vgHDD/HDD3sudo mkfs.xfs /dev/vgSSD/SSD 接下來掛載到/mnt，這邊放在/mnt裡面統一管理： 1sudo mkdir /mnt/HDD /mnt/SSD2sudo mount /dev/vgHDD/HDD /mnt/HDD3sudo mount /dev/vgSSD/SSD /mnt/SSD 管理LVM在網路上找到這張圖： 使用方法就是(PV, VG, LV) + 左邊的指令： 1# 查看所有LVM的PV2sudo pvs3# 查看更詳細的資訊4sudo pvdisplay 另外如果以後新增了更多硬碟，也可以透過lvcreate來組成RAID1, RAID5, RAID6。 補充因為之前硬碟放在其他系統上運作，所以上面有一些預設的磁區，我發現上面有些詞曲沒刪乾淨，所以遇到了下面這個狀況，硬碟是HDD的硬碟： 看了很討厭，所以就進行了更改： 1# 卸載之前掛載的PV2sudo umount /dev/vgHDD/HDD3# 刪除LV4sudo lvremove vgHDD/HDD5# 轉移資料，將/dev/sda1裡的資料轉移出去6sudo pvmove /dev/sda17# 從VG中移除PV8sudo vgreduce vgHDD /dev/sda1 這時候你可以透過Gparted或是用lvm的指令來建立新的lvm分區，再來將新的分區添加到vgHDD中： 1sudo vgextend vgHDD /dev/sda1 接下來重複上面的格式化跟掛載步驟就行。","link":"/2019/12/19/DeepLearning-02/"},{"title":"hexo系列-00 hexo簡介＆環境安裝","text":"A fast, simple &amp; powerful blog framework 前言一直以來就有想要架設個人網站的想法，之前在學寫HTML的時候，有試過用github.io的功能，他可以直接把你寫的網頁直接呈現在外部ip。(在大學的時候有想過用這個功能把專題直接讓每個人玩，不過後來發現，他只能用靜態網頁所以後來就不了了之。) 身為一個懶惰又想要讓自己的網站很炫能看的資訊工程學生，在一看到hexo這個工具，就立刻架設了一個範本，也就是現在你所看到的這個網站，經過研究一段時間後發現，架設這個網站只需要簡單的幾個指令就可以完成，基本上不需要資訊工程或是有編程經驗的背景就可以使用了。 不過要注意的是hexo是一個基於Node.js的靜態blog工具，可以很方便的將生成的網頁直接放在Github上面，不過要注意的是他跟基於PHP的WordPress不一樣，如果你想搭建功能比較複雜的網頁或是WebAPP的話，還是採用動態網站比較好。 之後會慢慢的完善這個網頁，接下來就直接開始介紹怎麼使用hexo這個工具吧～ 環境安裝、配置NodeJS/NPMNodeJS是能夠在電腦運行JavaScript的開放原始碼，幾本上所有在寫前端的程序猿都會需要使用，安裝方法很簡單，去NodeJS官方網站下載一個LTS的版本就可以了，如果你電腦安裝過了就可以直接跳過。 有許多人在JavaScript上發佈、使用許多模塊，要調用也十分容易，其中NPM是最有名的社群，也是國際上最為流行的Node模塊管理工具，現在的NodeJS已經集成了NPM，所以不需要再去安裝。 Git/Github去Git官網下載和自己作業系統相對應的安裝包，另外如果沒有Github帳戶的人也需要去申請一個。 另外要記得設定全局變量還有ssh-key 1git config --global user.name \"Your Github username\"2git config --global user.email \"Your Github mail address\"3ssh-keygen -t rsa -C \"Your Github mail address\" 然後可以在家目錄~/裡面看到.ssh文件夾，在裡面會有id_rsa.pub這個檔案，可以使用pbcopy這個指令來複製key。 1pbcopy &lt; ~/.ssh/id_rsa.pub 然後到Github SSH and GPG keys新增你的key，標題隨意打一個就行，新增完後以後要發文就不需要再輸入Github的密碼了。 Hexohexo可以直接使用npm來進行安裝： 1npm install hexo-cli -g 到這邊基本的環境就算安裝完成。 進入你要創建hexo的目錄(建議創建的目錄為XXX.github.io)，接下來初始化hexo的環境： 1hexo init XXX.github.io2cd XXX.github.io3npm install4hexo server 到這個步驟你就可以直接用瀏覽器打開localhost:4000(默認的port，也可以用hexo server -p XXXX來指定你的連接埠)，預設的主題是landscape。 到這裡你就可以開始使用你個人的blog了，下一篇會介紹如何更改主題、上傳到Github Page等等。 Hexo建置在使用的hexo之前，我想各位都已經找到自己感興趣的網站樣板了吧？！(至少我是XD) 如果還沒有開始找想要的樣板也沒關係，這裏列出了很多不同的樣板可以去參考看看。 主題安裝這裡我挑選的是Icarus作為我的主題，然後直接在~/XXX.github.io這個目錄下面輸入： 1git clone https://github.com/ppoffice/hexo-theme-icarus.git themes/icarus 這樣就可以直接把主題安裝到目錄中的themes資料夾了。 如果在這之前你是使用過hexo的人要轉換主題，你要先執行： 1hexo clean 清除之前主題渲染過內容的檔案，再重新渲染一次才不會有問題。 設置文件在執行完上面步驟之後，你會在資料夾發現兩個_config.yml，一個在XXX.github.io資料夾內，另一個在剛剛下載的主題內。 接下來將XXX.github.io內的_config.yml打開，將theme改寫成你主題的名字： 1theme: icarus 接著執行選染的指令： 1hexo generate2hexo g #簡寫當然也是可以的 最後就可以在瀏覽器看結果囉～ 1hexo server 預設地址為：http://localhost:4000 新增貼文接下來是新增貼文，在目錄中使用下面這個指令就可以新增貼文了： 1hexo new post 'title' 然後在XXX.github.io/source/_posts/這資料夾內就會看到剛剛新增的title.md檔案，文章標題默認會和檔案名稱一樣，打開這個md檔長得像這樣： 1---2title: title3date: 2019-12-10 15:05:404tags:5--- 這邊就是單純的Markdown語法，無須多說。不過在頂部的設定區有一些有趣的選項，譬如tag, categories, thumbnail, toc，其中thumbnail和toc分別代表的是縮圖跟目錄，可以用以下的方式設定： 1---2title: title3date: 2019-12-10 15:05:404tags: [A,B]5categories: C6thumbnail: /uploads/YourImage.JPG7toc: true8--- 這邊要注意的是圖片的位置，這邊個人建議是在XXX.github.io/public/裡面新增一個資料夾叫做uploads，之後你文章中所使用的任何圖片都可以上傳到這裡在用/uploads/YourImage.JPG的方式指定到目標位置。 當然如果你要建立子資料夾來管理圖片也是可以的，之後文章會介紹post_asset_folder讓圖片可以放在_posts裡面，用文章的名稱來管理用到的圖片。 上傳到Github前面有申請過Github的帳戶，現在我們要將網站發佈在Github Page上面，首先要做的是打開XXX.github.io下的_config.yml檔案，找到Deployment將其改成像下面這段： 1# Deployment2## Docs: https://hexo.io/docs/deployment.html3deploy:4 type: 'git'5 repo: https://github.com/YourAccount/XXX.github.io.git6 branch: master7 message: 變更成你的配置，不過不建議在message加上內容，我們可以在後面加上message的訊息，記得要先generate才可以上傳到你的Github帳戶： 1hexo generate2hexo depoly -m \"github message\" 建議在這裡加上附註，因為可以使用一些git的技巧，直接在-m後面加上要傳上去的附註，當然也可以將上傳的時間點加在附註上面，像是這樣的形式： 1hexo d -m \"Site updated: `date +'%Y-%m-%d %H:%M:%S'`\" 結語以上就是關於hexo的基本操作方式，接下來會針對_config.yml檔案裡面的參數去做介紹。","link":"/2019/12/09/hexo-00/"},{"title":"hexo系列-01 hexo簡單配置","text":"theme下的_config.yml前面有介紹過hexo在生成主題之後會有兩個_config.yml，這邊著重介紹在theme中的設定(絕對不是hexo原生的_config.yml沒什麼好介紹的) favicon&amp;logo首先就是favorites icon和logo~ 你可以在_config.yml裡面找到： 1# Path or URL to the website's icon23favicon: /images/favicon.png45# Path or URL to the website's logo to be shown on the left of the navigation bar or footer67logo: /images/logo.png 然後打開你的目錄XXX.github.io/public/images/裡面找到相對應的圖檔，間單的替換+更改檔名就可以放上你想要的圖片囉～ share分享的方式Icarus提供了許多方式，預設是： 1# Share2share: default # options: jiathis, bdshare, addtoany, default 這邊我使用的是AddThis在連結中註冊帳戶，他可以透過google, Facebook或是Twitter註冊帳戶，這個網站不只有分享按鈕的JavaScript，詳細功能可以自行去探索，設定好後會得到像是這樣的code 1//s7.addthis.com/js/300/addthis_widget.js#pubid=xxxxxxxx 將share那段替換成： 1# Share2share:3 type: addthis4 install_url: //s7.addthis.com/js/300/addthis_widget.js#pubid=xxxxxxxx # (required) 如此就可以直接在你的post上面看到我頁面上的分享按鈕了～ Donate當你建置好你的網站後你可能會發現下面這樣的狀況： 這是因為你在Donate的選項中沒有設置完全，直接把它註解掉就可以解決這個問題了。 1# donate:2 # -3 # # Donation entry name4 # type: alipay5 # # Qrcode image URL6 # qrcode: ''7 # -8 # # Donation entry name9 # type: wechat10 # # Qrcode image URL11 # qrcode: ''12 # -13 # # Donation entry name14 # type: paypal15 # # Paypal business ID or email address16 # business: 'V6DFAWSEDJJHE'17 # # Currency code18 # currency_code: U19 # -20 # # Donation entry name21 # type: patreon22 # # URL to the Patreon page23 # url: '' 當然如果你要設置Donate的帳戶也完全沒問題😜 highlight接著是highlight選項，這個是程式碼區塊的顯示格式，可以透過這裡去預覽、這裡去下載。 簡單的將highlight名稱替換成你想要的樣板名稱就可以裡： 1# Code highlight settings2highlight: 3 # Code highlight themes4 # https://github.com/highlightjs/highlight.js/tree/master/src/styles5 theme: zenburn6 # Show code copying button7 clipboard: true8 # Default folding status of the code blocks. Can be \"\", \"folded\", \"unfolded\"9 fold: unfolded 這裏我選擇的是zenburn，理由就是我覺得好看這個暗色主題黑的剛剛好，不會想其他主題一樣太黑，或者是不夠黑。 widgets這個選項就是調整你在頁面上所看到所有一塊塊區域的內容跟功能，第一個區塊就是網頁簡單名片： 在_config.yml的widgets第一個區塊就是相關的設定，包含像是位置、作者、還有圖片等等。在預設中沒有的是Envelope選項，也就是上面那張圖的右下角，可以通過更改social_links來將你的信箱新增上去： 1social_links:2 Github:3 icon: fab fa-github4 url: 'https://github.com/AugustusHsu'5 Facebook:6 icon: fab fa-facebook7 url: 'https://www.facebook.com/HsuAugustus'8 Envelope:9 icon: fas fa-envelope10 url: mailto:jimhsu11@gmail.com 這樣設置後，只要點擊你的信箱那個圖示，電腦會自動跳到寫信的應用程式(不過這年代還有誰會用Email來寫信😆) 其他功能我都是使用預設選項，當然其中會有像是： 1position: left 這樣的選項，你可以自行調整要放在左右那一邊，當然你也可以直接註解掉整塊來取消這個功能。 Image管理在Hexo你的發文可以透過MarkDown語法來編寫，所以在引用圖片的時候是可以透過第三方的網站來上傳圖片，再利用： 1！[title](image link) 來展示你的圖片，那如果想要將圖片放在你的網頁資料夾中的話，要怎麼引用呢？ hexo-asset-image這邊可以直接安裝這個插件，在新增貼文的時候會同時產生一個同名的資料夾，把圖片丟進資料夾再飲用就可以了。 在XXX.github.io資料夾輸入以下命令： 1npm install hexo-asset-image --save 另外在XXX.github.io中的_config.yml： 1post_asset_folder: true 將它改成true，這樣在新增貼文的時候就會自動產生同名的資料夾了。 實際運用如果你的圖片放在同名資料夾的話，在文章中要引用圖片的話，要像下面這個例子一樣： 1！[title](image_name.jpg) 無需加上資料夾的名稱，直接打你的圖片檔名就可以引用了。 不過這邊要注意的是如果你這樣打，在MarkDown編輯器中，你圖片會看不到，還有如果你是一邊啟動hexo server在編輯的話，你在網頁上圖片也是會顯示不出來，要執行過一次： 1hexo g 才能正常的在localhost:4000中看到圖片。 留言設置文章當然免不了討論問題，那在文章底部新增一個互動機制也就是留言功能，就在所難免。 在這個留言設置中，我只舉出兩種我有實際操作過的方法，其他像是gitment在Icarus列出的方法就請有興趣的朋友自行研究了。 gitalkgitalk是使用github上面的issue功能實現的留言討論功能，所以要跟github做連結。 OAuth OAuth是一個開放標準，允許用戶讓第三方應用存取該用戶在某一網站上儲存的私密的資源，而無需將用戶名稱和密碼提供給第三方應用。 –Wiki 也就是要授權github來儲存對話紀錄，點擊這裡來申請一個OAuth 其中Homepage URL跟Authorization callback URL請填你github.io的網址，name就簡單填個就行。 申請完會得到Client ID跟Client Secret將這兩項填入： 1comment:2 type: gitalk3 owner: xxxxxxxx # (required) GitHub user name4 repo: xxxxxxxx # (required) GitHub repository name5 client_id: xxxxxxxx # (required) OAuth application client id6 client_secret: xxxxxxxx # (required) OAuth application client secret7 admin: xxxxxxxx # (required) GitHub repo owner and collaborators who can initialize github issues8 # Can either be a string or an array.9 # admin:10 # - xxxxxx111 # - xxxxxx2 owner跟admin就直接填你github帳戶名稱就行。 一開始你可能會遇到像是這樣： 這時候直接按下去就會要你去登入並授權這個應用功能： 結束後你就可以在文章下方看到跟我一樣的留言區塊了。 facebookfacebook的話比較簡單，不過我之前有遇到過他的寬度不太合的狀況，所以比較推薦使用gitalk的方式來增加留言功能。 facebook的方式一樣要先授權，所以點這裡將你github.io的網址填入，接著按下取得程式碼就可以了。 再來要在_config.yml裡面把comment的設定更改成facebook: 1comment:2 type: facebook 這樣就設定完成了。 補充你在首頁看到我的文章會看到Read More這個框框，這個是MarkDown的語法，直接在你想隱藏的段落前加上： 1&lt;!--more--&gt; 就可以摺疊你的貼文了。","link":"/2019/12/10/hexo-01/"},{"title":"hexo系列-02 hexo個人化設置","text":"前言在用主題模板的時候，總有些時候會覺得網頁版面怪怪的、不盡人意的地方，那要怎麼改呢？ 這邊列出了我對Icarus主題的改動地方，這篇的東西都是參考下列網址： https://www.alphalxy.com/2019/03/customize-icarus https://dp2px.com/2019/06/04/icarus-theme/ https://github.com/ppoffice/hexo-theme-icarus/issues/379 然後我這邊不是全部採用，而是選取部分內容時做到我的網站上，不過話說前頭，本人不是專業的前端工程師，所以大部分內容都只是參考一下就直接照抄，如果對本文內容不夠滿意的話，建議可以直接去看上面的網址內容。 佈局Icarus的主題默認上是三欄式網頁佈局，不過這個模式在瀏覽文章的時候總會覺得版面有些太滿，所以這邊我將閱讀文章的佈局改成兩欄式的佈局。 文章佈局-兩欄式佈局打開includes/helpers/layout.js找到下面紅字那行替換成綠字那行，記得不要複製到+號： 1const widgets = hexo.extend.helper.get('get_config').bind(this)('widgets');2- return widgets.filter(widget =&gt; widget.hasOwnProperty('position') &amp;&amp; widget.position === position);3+ if (this.page.layout !== 'post') {4+ return widgets.filter(widget =&gt; widget.hasOwnProperty('position') &amp;&amp; widget.position === position);5+ }6+ if (position === 'left') {7+ return widgets.filter(widget =&gt; widget.hasOwnProperty('position') &amp;&amp; (widget.type === 'toc' || widget.type === 'profile'));8+ } else {9+ return []10+ } 這邊可以注意到page.layout是頁面的類型，當他是'post'時代表當前是文章閱讀的模式，當然你也可以針對其他頁面去做調整，像是index代表首頁、tag代表標籤頁。 詳細的網頁類別可以點這裡查到。 if (position === 'left')這段代表的是小工具載入的位置，你也可以設定成'right'來讓你後續要載入的小工具展是在右邊。 後面的widget.type代表的是要列在上面指定位置的小工具，可以透過||來增加你想展示的小工具。 接下來因為兩籃式佈局跟三欄式佈局整體的寬度不一樣，所以要調整layout/common/widget.ejs這個檔案： 1&lt;% function side_column_class() {2 switch (column_count()) {3 case 2:4- return 'is-4-tablet is-4-desktop is-4-widescreen';5+ return 'is-4-tablet is-4-desktop is-3-widescreen';6 case 3: 還有這個檔案layout/layout.ejs： 1-&lt;body class=\"is-&lt;%= column_count() %&gt;-column\"&gt;2+&lt;body class=\"is-3-column\"&gt;3 &lt;%- partial('common/navbar', { page }) %&gt;4 &lt;% function main_column_class() {5 switch (column_count()) {6 case 1:7 return 'is-12';8 case 2:9- return 'is-8-tablet is-8-desktop is-8-widescreen';10+ return 'is-8-tablet is-8-desktop is-9-widescreen'; 因為Icarus有針對響應式去做設計，所以要更改source/css/style.styl，針對不同螢幕寬度有相應的呈現： 1 .is-2-column .container2 max-width: screen-desktop - 2 * gap3 width: screen-desktop - 2 * gap4+ .is-3-column .container5+ max-width: screen-widescreen - gap6+ width: screen-widescreen - gap7 @media screen and (min-width: screen-fullhd)8+ .is-3-column .container9+ max-width: screen-fullhd - 2 * gap10+ width: screen-fullhd - 2 * gap11 .is-2-column .container12 max-width: screen-widescreen - 2 * gap13 width: screen-widescreen - 2 * gap 標題佈局-更新時間和icon接下來新增文章標題的更新時間和標籤icon，更改layout/common/article.ejs： 1 &lt;% if (post.layout != 'page') { %&gt;2 &lt;div class=\"level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto\"&gt;3 &lt;div class=\"level-left\"&gt;4- &lt;time class=\"level-item has-text-grey\" datetime=\"&lt;%= date_xml(post.date) %&gt;\"&gt;&lt;%= date(post.date) %&gt;&lt;/time&gt;5+ &lt;time class=\"level-item has-text-grey\" datetime=\"&lt;%= date_xml(post.date) %&gt;\"&gt;&lt;i class=\"far fa-calendar-alt\"&gt;&amp;nbsp;&lt;/i&gt;&lt;%= date(post.date) %&gt;&lt;/time&gt;6+ &lt;% if (post.updated &amp;&amp; post.updated &gt; post.date) { %&gt;7+ &lt;time class=\"level-item has-text-grey is-hidden-mobile\" datetime=\"&lt;%= date_xml(post.updated) %&gt;\"&gt;&lt;i class=\"far fa-calendar-check\"&gt;&amp;nbsp;&lt;/i&gt;&lt;%= date(post.updated) %&gt;&lt;/time&gt;8+ &lt;% } %&gt;9 &lt;% if (post.categories &amp;&amp; post.categories.length) { %&gt; 然後要刪除source/js/main.js中的部分程式碼： 1- if (typeof(moment) === 'function') {2- $('.article-meta time').each(function () {3- $(this).text(moment($(this).attr('datetime')).fromNow());4- });5- } 我這邊遇到了一個問題：在source/js/main.js找不到上面那段刪除，這邊猜測是要執行hexo g之後才會產生上面那段程式碼，如果找不到要刪除的程式碼，記得要去generate一次你的網站。 完成的模樣會像是這樣的狀況： 文章結尾佈局-修改tag展示這邊在文章底部增加了一個hr，然後針對文章的預覽還有結尾加上了tag的icon，修改layout/common/article.ejs這個檔案： 1 &lt;% if (!index &amp;&amp; post.tags &amp;&amp; post.tags.length) { %&gt;2+ &lt;hr style=\"height:1px;margin:1rem 0\"/&gt;3 &lt;div class=\"level is-size-7 is-uppercase\"&gt;4 &lt;div class=\"level-start\"&gt;5 &lt;div class=\"level-item\"&gt;6- &lt;span class=\"is-size-6 has-text-grey has-mr-7\"&gt;#&lt;/span&gt;7+ &lt;i class=\"fas fa-tags has-text-grey\"&gt;&lt;/i&gt;&amp;nbsp;8 &lt;%- list_tags(post.tags, {9 class: 'has-link-grey ',10 show_count: false,11- style: 'link'12+ style: 'link',13+ separator: ',&amp;nbsp;'14 }) %&gt;15 &lt;/div&gt;16 &lt;/div&gt;17 &lt;/div&gt;18 &lt;% } %&gt;19 &lt;% if (index &amp;&amp; post.excerpt) { %&gt;20- &lt;div class=\"level is-mobile\"&gt;21+ &lt;hr style=\"height:1px;margin:1rem 0\"/&gt;22+ &lt;div class=\"level is-mobile is-flex\"&gt;23+ &lt;div class=\"level-start\"&gt;24+ &lt;% if (post.tags &amp;&amp; post.tags.length) { %&gt;25+ &lt;div class=\"level-item is-size-7 is-uppercase\"&gt;26+ &lt;i class=\"fas fa-tags has-text-grey\"&gt;&lt;/i&gt;&amp;nbsp;27+ &lt;%- list_tags(post.tags, {28+ class: 'has-link-grey ',29+ show_count: false,30+ style: 'link',31+ separator: ',&amp;nbsp;'32+ }) %&gt;33+ &lt;/div&gt;34+ &lt;% } %&gt;35+ &lt;/div&gt;36 &lt;div class=\"level-start\"&gt; 手機顯示優化在使用手機瀏覽網站的時候，隱藏archive和tagcloud小工具，修改layout/widget/archive.ejs： 1-&lt;div class=\"card widget\"&gt;2+&lt;div class=\"card widget is-hidden-mobile\"&gt; layout/widget/tagcloud.ejs： 1-&lt;div class=\"card widget\"&gt;2+&lt;div class=\"card widget is-hidden-mobile\"&gt; 當然，你可以在layout/widget/裡面找你想要隱藏的小工具，一樣套用上面的方式。 固定目錄將文章的目錄固定在一個位置，不會隨著網頁的滾動而看不到目錄，這邊只需簡單的修改layout/widget/toc.ejs就可以了： 1-&lt;div class=\"card widget\" id=\"toc\"&gt;2+&lt;div class=\"card widget column-left is-sticky\" id=\"toc\"&gt; 功能接下來針對網頁的功能去做新增跟修正。 版權宣告在layout/common/article.ejs新增： 1 &lt;div class=\"content\"&gt;2 &lt;%- index &amp;&amp; post.excerpt ? post.excerpt : post.content %&gt;3 &lt;/div&gt;4+ &lt;% if (!index &amp;&amp; post.layout === 'post' &amp;&amp; post.copyright !== false) { %&gt;5+ &lt;ul class=\"post-copyright\"&gt;6+ &lt;li&gt;&lt;strong&gt;文章標題：&lt;/strong&gt;&lt;a href=\"&lt;%= post.permalink %&gt;\"&gt;&lt;%= page.title %&gt;&lt;/a&gt;&lt;/li&gt;7+ &lt;li&gt;&lt;strong&gt;文章作者：&lt;/strong&gt;&lt;a href=\"&lt;%= theme.url %&gt;\"&gt;&lt;%= theme.author %&gt;&lt;/a&gt;&lt;/li&gt;8+ &lt;li&gt;&lt;strong&gt;文章連結：&lt;/strong&gt;&lt;a href=\"&lt;%= post.permalink %&gt;\"&gt;&lt;%= post.permalink %&gt;&lt;/a&gt;&lt;/li&gt;9+ &lt;li&gt;&lt;strong&gt;發佈時間：&lt;/strong&gt;&lt;%= post.date.format(\"YYYY-MM-DD\") %&gt;&lt;/li&gt;10+ &lt;li&gt;&lt;strong&gt;版權聲明：&lt;/strong&gt;本博客所有文章除特別聲明外，均採用 &lt;a href=\"https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh\" rel=\"external nofollow\" target=\"_blank\"&gt;CC BY-NC-SA 4.0&lt;/a&gt; 許可協議。引用請註明出處！11+ &lt;/li&gt;12+ &lt;/ul&gt;13+ &lt;% } %&gt;14 &lt;% if (!index &amp;&amp; post.tags &amp;&amp; post.tags.length) { %&gt; 然後增加css樣式，在source/css/style.styl新增： 1/* ---------------------------------2 * Copyright3 * --------------------------------- */4+.post-copyright5+ font-size: 1rem6+ letter-spacing: 0.02rem7+ word-break: break-all8+ margin: 2.5rem 0 09+ padding: 1rem 1rem10+ border-left: 3px solid #FF170011+ background-color: #F9F9F9 默認使用目錄小工具正常在寫文章的時候，要啟用目錄的功能時，需要在meta資料中加入toc: true來開啟目錄小工具，不過大多數時候都會在文章中使用目錄，所以這邊讓他在默認的時候加入toc: true，修改includes/helpers/config.js： 1 return defaultValue;2 } else {3 const property = readProperty(specs, configName);4- return property === null ? null : property[descriptors.defaultValue];5+ const result = property === null ? null : property[descriptors.defaultValue];6+ return (configName === 'toc' &amp;&amp; this.page.layout === 'post' &amp;&amp; result === null) ? true : result;7 } footer顯示一組icon在版權的地方有寫到採用CC BY-NC-SA 4.0，而CC BY-NC-SA 4.0的icon是四個一組，所以要讓在配置link.icon可以是一個數組的方式呈現。 修改layout/common/footer.ejs： 1 &lt;% } else { %&gt;2- &lt;i class=\"&lt;%= link.icon %&gt;\"&gt;&lt;/i&gt;3+ &lt;% for (let icon of (Array.isArray(link.icon) ? link.icon : [link.icon])) { %&gt;&lt;i class=\"&lt;%= icon %&gt;\"&gt;&lt;/i&gt;&amp;nbsp;&lt;% } %&gt;4 &lt;% } %&gt; 和includes/specs/icon_link.spec.js： 1 icon: {2 [required]: true,3- [type]: 'string',4+ [type]: ['string', 'array'],5 [doc]: 'Link icon class names' 另外在_config.yml中修改成這樣： 1footer:2 links:3 CC BY-NC-SA 4.0:4 icon:5 - fab fa-creative-commons6 - fab fa-creative-commons-by7 - fab fa-creative-commons-nc8 - fab fa-creative-commons-sa9 url: 'https://creativecommons.org/licenses/by-nc-sa/4.0/' 樣式按鈕、背景顏色增加漸變讓一些按鈕(例如profile中的文章、分類等)有陰影、漸變的效果，修改source/css/style.styl： 1 .menu-list li ul2 margin-right: 03+ .menu-list a4+ transition: background-color 0.3s ease-in-out5 .menu-list a.level6 display: flex 區塊增加浮動效果:hover時曾大陰影面積，增加動畫屬性ease-in-out，修改source/css/style.styl： 1 .card2 border-radius: 4px3 box-shadow: 0 4px 10px rgba(0,0,0,0.05), 0 0 1px rgba(0,0,0,0.1)4+ &amp;:hover5+ box-shadow: 0 6px 15px rgba(0,0,0,0.15), 0 0 1px rgba(0,0,0,0.1) 還有source/js/animation.js： 1 element.style.transform = '';2- element.style.transition = 'opacity 0.3s ease-out, transform 0.3s ease-out';3+ element.style.transition = 'opacity 0.3s ease-out, transform 0.3s ease-out, box-shadow 0.3s ease-in-out'; 這樣修改能看到在滑鼠移到各個區塊的時候會有淡淡的陰影，可以更改上面數值讓他變得明顯或是淡化它。 結語這篇是參考alphalxy這個網站上面的設置(並不是全都採用)，我在最上面也有留這個網站的連結，實作完之後版面的規劃跟細節，讓觀看的舒適度大大的增加也讓我比較順眼了。 如果你有找到更好的設置，歡迎留言給我，之後如果有其他有趣的功能會在實作後分享上來～","link":"/2019/12/11/hexo-02/"},{"title":"hexo系列-03 讓google可以搜尋到你的網站","text":"前言原本以為要讓自己的網站在網路上可以被搜尋到，只要能用網址打開網站，之後Google搜尋引擎就可以搜尋到相對應的內容，沒有想到事情不是那麼簡單的我還是太年輕了。 要讓搜尋引擎能搜到自己的網站，首先要去Google網站管理員的Google Search Console提交網站的一些設定，詳細的會在下面一一列出。 安裝sitemap套件1npm install hexo-generator-sitemap --save 安裝這個套件會直接幫你生成需要的檔案，接著在theme/_config.yml加上下面這段： 1#Sitemap2sitemap:3 path: sitemap.xml 接下來用： 1hexo g 生成sitemap.xml的檔案，位於XXX.github.io/public/中。 創建robots.txt在XXX.github.io/source中創建robots.txt文件： 1# hexo robots.txt2User-agent: *3Allow: /4Allow: /archives/5Allow: /categories/6Allow: /tags/7Allow: /about/ 89# Disallow: /js/10# Disallow: /css/11# Disallow: /fancybox/1213Sitemap: https://augustushsu.github.io/sitemap.xml robots.txt是用來告訴網路搜尋引擎的漫遊器(又稱網路蜘蛛)，此網站中的哪些內容是不應被搜尋引擎的漫遊器取得的，哪些是可以被漫遊器取得的。 其中Allow後面加的就是你的menu，也就是允許漫遊器搜尋的到網頁，而Disallow則相反。 你可以將在測試的網頁資料夾寫在Disallow上，這樣一些漫遊器就不會去搜到你不想公開的網頁囉，詳細的說明可以參考Googel文件，還有這篇文章。 Google Search Console前面有說要讓Google搜尋的到你需要在Google Search Console中填寫關於你訊息，登入Google帳戶後，你應該會看到這樣的畫面： 輸入你Github上的網址，之後會要你去驗證： 這邊選擇的是用HTML標記，將google提供的html程式碼複製到XXX.github.io/themes/icarus/layout/common/head.ejs，直接加在最上面就可以： 接著上傳到GitHub： 1hexo -g d 按下驗證，如果設置的正確，就會跳出以下畫面： 接下來要將剛剛建的sitemap.xml提交到Google Search Console： 驗證之後，Google會花一些時間將你的網站建檔，等過了一天你就可以用Google Search Console來分析自己的網頁囉～ robots.txt點選網址審查把你的網頁貼上，會顯示正在從 Google 索引擷取資料完成後，點選查看以檢索的網頁再點更多資訊就可以看到前面Disallow不想讓其他人看到的部分了： Google Analytics打開Google Analytics網站，註冊一個帳號，然後點選追蹤程式碼，複製你的追蹤ID，形式大概是UA-XXXXXXXX-X。 將上面的ID輸入到Icarus下_config.yml檔案中的： 1google-analytics:2 # Google Analytics tracking id3 tracking_id: UA-XXXXXXXX-X 最後再將你的成品上傳到Github就完成囉～ 1hexo -g d","link":"/2019/12/14/hexo-03/"}],"tags":[{"name":"ubuntu","slug":"ubuntu","link":"/tags/ubuntu/"},{"name":"ubuntu-18.04","slug":"ubuntu-18-04","link":"/tags/ubuntu-18-04/"},{"name":"xrdp","slug":"xrdp","link":"/tags/xrdp/"},{"name":"static ip","slug":"static-ip","link":"/tags/static-ip/"},{"name":"nvidia-gpu","slug":"nvidia-gpu","link":"/tags/nvidia-gpu/"},{"name":"docker-19.03","slug":"docker-19-03","link":"/tags/docker-19-03/"},{"name":"nvidia-docker","slug":"nvidia-docker","link":"/tags/nvidia-docker/"},{"name":"native gpu","slug":"native-gpu","link":"/tags/native-gpu/"},{"name":"nvidia-container-toolkit","slug":"nvidia-container-toolkit","link":"/tags/nvidia-container-toolkit/"},{"name":"lvm","slug":"lvm","link":"/tags/lvm/"},{"name":"pv","slug":"pv","link":"/tags/pv/"},{"name":"vg","slug":"vg","link":"/tags/vg/"},{"name":"lv","slug":"lv","link":"/tags/lv/"},{"name":"hexo","slug":"hexo","link":"/tags/hexo/"},{"name":"Google Search Console","slug":"Google-Search-Console","link":"/tags/Google-Search-Console/"},{"name":"Google Analytics","slug":"Google-Analytics","link":"/tags/Google-Analytics/"},{"name":"sitemap","slug":"sitemap","link":"/tags/sitemap/"}],"categories":[{"name":"DL Machine","slug":"DL-Machine","link":"/categories/DL-Machine/"},{"name":"hexo","slug":"hexo","link":"/categories/hexo/"}]}