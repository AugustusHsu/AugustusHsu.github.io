{"pages":[{"title":"about","text":"Strike the iron while it is hot.","link":"/about/index.html"}],"posts":[{"title":"DL Machine系列-00 環境建置","text":"前言有鑒於每次實驗架設環境都花很多時間，也常常遇到版本更新後某些套件不相容的問題，所以才打算使用Docker來架設深度學習的虛擬環境(絕對不是因為覺得用Docker很帥才用的)，說到深度學習就不得不使用GPU，使用GPU就不得不用nvidia-docker來架設環境，剛剛好本人的實驗室目前有一台電腦正空閒下來，也剛剛好多出一張RTX 2070S，想說利用Docker來一勞永逸這個問題，也順便試試看多GPU的環境是什麼樣的感覺。 電腦配置CPU： AMD Ryen Threadripper 1900X 8-coreMotherBoard：ROG Strix X399-E GammingGPU：RTX 2070 super, GTX 1050RAM：Kingston 16Gx8 2933MHzStorage：2TB SSD2, 1\\1TB m.2 SSDPower：750w金牌電源 Ubuntu 18.04安裝在安裝Ubuntu的時候，會顯示出 install ubuntu/ try ubuntu without installationinstall ubuntu 等等的選項，但是選擇後螢幕變黑屏沒反應。 經過查找，應該是因為Ubuntu對於RTX顯示卡沒有對應的Driver，所以導致這個問題。 我這邊使用另一張顯卡安裝，再去更新Nvidia-driver來避免這個問題。 安裝的時候選擇： 在新安裝的Ubuntu上使用LVM 這是因為之後新增硬碟用LVM來管理。 確認GPU狀態執行ubuntu-drivers devices去確認 如果你只有看到這一項：nvidia-driver-390 - distro non-free，那你必須去將NVIDIA repository加入到你的apt庫。 可以用dpkg -l 'nvidia*'去看電腦上安裝的Nvidia Driver 執行sudo ubuntu-drivers autoinstall安裝driver，完成之後執行nvidia-smi就可以看到： 安裝基本工具1sudo apt-get update2sudo apt-get upgrade3sudo apt-get install vim #好用的編輯器4sudo apt-get install net-tools curl #用來看網路介面卡5sudo apt-get install gparted #硬碟管理工具 設定ip(區域網路)打開/etc/netplan/01-network-manager-all.yaml更改成這樣： 1# Let NetworkManager manage all devices on this system2network:3 version: 24 # renderer: NetworkManager5 eno1:6 addresses: [192.168.123.111/24]7 gateway4: 192.168.111.18 nameservers:9 addresses: [8.8.8.8,8.8.4.4] 參數說明：eno1： 網卡名稱(可以透過ifconfig查看)addresses： 要指定的ipgateway4： 閘道 ip4(gateway6 閘道 ip6)nameservers： dns 以逗號階隔註：/32 指的是 network mask of 255.255.255.255/24 指的是 network mask of 255.255.255.0 依照個人網路調整即可，用sudo netplan apply就可以套用剛剛的設定了。 安裝vnc遠端操控安裝 xfce4 與 xrdp 1sudo apt-get install xfce42sudo apt-get install xrdp 配置登入環境 1echo xfce4-session &gt; ~/.xsession2sudo vim /etc/xrdp/startwm.sh 將stratum.sh更改： 1if test -r /etc/profile; then2 . /etc/profile3fi45test -x /etc/X11/Xsession &amp;&amp; exec /etc/X11/Xsession6-exec /bin/sh /etc/X11/Xsession7+startxfce4 啟動 xrdp 服務： 1sudo service xrdp restart 確認服務正常運行： 1netstat -na | grep 3389 這時就可以透過Windows的遠端桌面連線到你的Linux主機了： 補充可以透過： 1sudo lshw -html &gt; ~/hardware.html 來看這台電腦的硬體配備，用瀏覽器打開即可。","link":"/2019/12/17/DeepLearning-00/"},{"title":"DL Machine系列-03 Docker","text":"前言網路上關於Docker的資訊已經有很多了，這邊就不多作介紹了，只針對幾個常用和在我的實作上有用到的指令和套件去做介紹。 用一張圖來簡單的說明Docker的架構： PortainerPortainer是一個用來管理Docker的工具，他可以透過網頁來查看或管理目前執行的container等等，也可以很快速地進入一個正在執行的container，簡而言之就是一種用來管理Docker的圖形化介面。 安裝可以用docker search portainer來查看目前有哪些可以用的資源： 1sudo docker search portainer2# output3NAME DESCRIPTION STARS OFFICIAL AUTOMATED4portainer/portainer Making Docker management easy. https://porta… 14395portainer/agent An agent used to manage all the resources in… 506portainer/templates App Templates for Portainer http://portainer… 18 下載： 1docker pull portainer/portainer 依據官方的文件啟動container，當然你可以自訂你想要的port (第一個是host port，第二個是container port)： 1docker volume create portainer_data2docker run -d -p 9000:9000 \\3--name portainer \\4--restart always \\5-v /var/run/docker.sock:/var/run/docker.sock \\6-v portainer_data:/data \\7portainer/portainer 打開瀏覽器就能看到： 這樣就可以管理docker的image、container跟volume，還可以看到其他的資源。 常用Docker指令記錄一些常用的Docker指令，以備不時之需，不過我想protainer應該可以取代大部分功能： 1# 查看目前的image2docker images3# 刪除image4docker rmi [OPTIONS] IMAGE [IMAGE...]5# 查看目前運行的 container6docker ps7# 查看目前全部的 container（ 包含停止狀態的 container ）8docker ps -a9# 停止 Container10docker stop [OPTIONS] CONTAINER [CONTAINER...]11# 删除 Container12docker rm [OPTIONS] CONTAINER [CONTAINER...]13# 查看 Container 詳細資料14docker inspect [OPTIONS] NAME|ID [NAME|ID...]15# 查看 log16docker logs [OPTIONS] CONTAINER17# 顯示容器資源 ( CPU , I/O ...... )18docker stats [OPTIONS] [CONTAINER...]19# 停止指定的 CONTAINER 中全部的 processes20docker pause CONTAINER [CONTAINER...]21# 恢復指定暫停的 CONTAINER 中全部的 processes22docker unpause CONTAINER [CONTAINER...] docker stop : process 級別。 docker pause: container 級別。 實作Deep Learning環境我這裡選擇的image是ubuntu18.04，然後透過ARG來新增使用者： 1FROM ubuntu:18.042MAINTAINER jim jimhsu11@gmail.com34ARG USERNAME5ARG USERPWD DEBIAN_FRONTEND noninteractive接下來這個步驟很重要： 1# debconf to be non-interactive2ENV DEBIAN_FRONTEND noninteractive 因為ubuntu在安裝的時候，某些套件會需要輸入指令，這邊將它設定成沒有交互介面的模式來安裝。 Add User接著就是新增使用者，這邊新增使用者主要是為了之後的xrdp套件，在run docker的時候可以不用再去建立使用者，不過在build的時候要記得加上ARG參數: 1# Update and Add User2RUN apt-get update \\3 &amp;&amp; apt-get install -y vim sudo wget \\4 &amp;&amp; useradd -ms /bin/bash ${USERNAME}\\5 &amp;&amp; sudo adduser ${USERNAME} sudo\\6 &amp;&amp; echo ${USERNAME}:${USERPWD} | chpasswd xrdp這邊安裝xrdp套件，讓Windows系統可以透過遠端桌面連線連線到Container： 1# xrdp2RUN apt-get update \\3 &amp;&amp; apt-get install -y xfce4 xfce4-goodies xorg dbus-x11 x11-xserver-utils xrdp \\4 &amp;&amp; echo xfce4-session &gt; /home/${USERNAME}/.xsession \\5 &amp;&amp; sed -i \"s/^exec.*Xsession$/startxfce4/g\" \"/etc/xrdp/startwm.sh\" \\6 &amp;&amp; service xrdp restart 這邊跟一般安裝xrdp的過程一樣，其中sed是將/etc/xrdp/startwm.sh最後一行替換成startxfce4。 Anaconda這邊使用Anaconda來管理python的套件，雖然已經使用Docker來隔離系統了，不過還是習慣用Anaconda來建立python環境： 1# Install Anaconda2RUN wget --quiet https://repo.continuum.io/archive/Anaconda3-5.0.1-Linux-x86_64.sh -O ~/anaconda.sh \\3 &amp;&amp; /bin/bash ~/anaconda.sh -b -p /opt/conda \\4 &amp;&amp; rm ~/anaconda.sh \\5 &amp;&amp; echo \"export PATH=/opt/conda/bin:$PATH\" &gt;&gt; /home/${USERNAME}/.bashrc \\6 &amp;&amp; sudo chown -R ${USERNAME}:${USERNAME} /opt/conda 這邊wget後面的網址可以自己去更改，找符合自己需求的版本來安裝。 然後安裝Anaconda的時候會需要輸入一些指令，所以用-b使用預設值安裝。 -p後面接的是安裝位置，這邊也可以自己去調整。 cuda &amp; cudnn我這邊cuda使用的版本是10.0，雖然在系統上是安裝的版本是10.1，不過經過測試，是不影響使用的。 我是使用Nvidia/cuda的Dockerfile指令來安裝cuda和cudnn，分別將nvidia/cuda:10.0-base-ubuntu18.04、nvidia/cuda:10.0-runtime-ubuntu18.04和nvidia/cuda:10.0-cudnn7-runtime-ubuntu18.04上需要的Dockerfile指令，加到自己的Dockerfile： 1#-------------------From Nvidia-------------------2# Nvidia install list3RUN apt-get update \\4 &amp;&amp; apt-get install -y --no-install-recommends gnupg2 curl ca-certificates \\5 &amp;&amp; curl -fsSL https://developer.download.nvidia.com/compute/cuda/repos/ubuntu1804/x86_64/7fa2af80.pub | apt-key add - \\6 &amp;&amp; echo \"deb https://developer.download.nvidia.com/compute/cuda/repos/ubuntu1804/x86_64 /\" &gt; /etc/apt/sources.list.d/cuda.list \\7 &amp;&amp; echo \"deb https://developer.download.nvidia.com/compute/machine-learning/repos/ubuntu1804/x86_64 /\" &gt; /etc/apt/sources.list.d/nvidia-ml.list \\8 &amp;&amp; apt-get purge --autoremove -y curl \\9 &amp;&amp; rm -rf /var/lib/apt/lists/*1011ENV CUDA_VERSION 10.0.13012ENV CUDA_PKG_VERSION 10-0=$CUDA_VERSION-11314# For libraries in the cuda-compat-* package: https://docs.nvidia.com/cuda/eula/index.html#attachment-a15RUN apt-get update \\16 &amp;&amp; apt-get install -y --no-install-recommends \\17 cuda-cudart-$CUDA_PKG_VERSION \\18 cuda-compat-10-0 \\19 &amp;&amp; ln -s cuda-10.0 /usr/local/cuda \\20 &amp;&amp; rm -rf /var/lib/apt/lists/*2122ENV PATH /usr/local/nvidia/bin:/usr/local/cuda/bin:${PATH}23ENV LD_LIBRARY_PATH /usr/local/nvidia/lib:/usr/local/nvidia/lib6424ENV NCCL_VERSION 2.4.22526RUN apt-get update \\27 &amp;&amp; apt-get install -y --no-install-recommends \\28 cuda-libraries-$CUDA_PKG_VERSION \\29 cuda-nvtx-$CUDA_PKG_VERSION \\30 libnccl2=$NCCL_VERSION-1+cuda10.0 \\31 &amp;&amp; apt-mark hold libnccl2 \\32 &amp;&amp; rm -rf /var/lib/apt/lists/*3334ENV CUDNN_VERSION 7.6.0.643536LABEL com.nvidia.cudnn.version=\"${CUDNN_VERSION}\"3738RUN apt-get update \\39 &amp;&amp; apt-get install -y --no-install-recommends \\40 libcudnn7=$CUDNN_VERSION-1+cuda10.0 \\41 &amp;&amp; apt-mark hold libcudnn7 \\42 &amp;&amp; rm -rf /var/lib/apt/lists/*43#-------------------Nvidia End------------------- 這邊有試過用nvidia本身的image來建立，不過失敗了，後來將nvidia上Dockerfile複製自己需要的部分卻成功了，原因沒有深究，如果有人知道的話，歡迎留言告訴我。 以上就是我的Dockerfile所有的內容。 Build &amp; Run &amp; Upload上面可以看到我的功能是一層一層添加的，實際上實作完一層，我就會build和run一次那個Dockerfile，以確保我的Dockerfile沒有寫錯，所以接下來就是將剛剛寫完的Dockerfile建立起來。 Build Dockerfile進入Dockerfile所在的資料夾，執行以下指令： 1sudo docker build -t image_name:tag \\2--build-arg USERNAME=username \\3--build-arg USERPWD=yourpassword . -t後面接的是image的名字跟tag，USERNAME跟USERPWD就是登入系統時要輸入的帳密，這樣image就建立好了。 Run Image執行下列命令就可以進入到創立的container了： 1sudo docker run --gpus device=1 -it \\2-p 33890:3389 \\3-v /mnt/SSD:/data/SSD \\4-v /mnt/HDD:/data/HDD \\5-v /docker_config/config:/config \\6image_name:tag --gpus:可以指令你要用的gpu，當然是要你電腦上有安裝複數的gpu才能指令，不然可以直接用--gpus all來使用全部的gpu。 -p:因為有使用xrdp套件，而這個套件使用的port是3389，所以要將container的port映射到主機上的port，這邊選擇加上一個0。 -v:可以將主機上的資料夾位置映射到container上面，也可以是docker的volume映射到container上。這邊要注意的是冒號，冒號前是主機上的位置；後面是container上的位置。 -it：建立好後會直接進入container。 接下來要啟動xrdp套件才可以連線進去，執行： 1service xrdp restart 啟動遠端桌面連線程式，輸入你主機的ip： 再輸入前面設定的帳號密碼： 進入到你的環境後，要記得進入Setting Manager： 打開Preferred Applications： 選擇Utilities，將預設的Terminal Emulator改成Xfce Terminal： 這樣就可以用Terminal了。 Docker Hub實作完自己的Dockerfile之後，用Docker Hub備份或是分享到網上。 第一步要當然是註冊一個帳號，再利用docker login來登入： 1docker login2# output3Login with your Docker ID to push and pull images from Docker Hub. If you don't have a Docker ID, head over to https://hub.docker.com to create one.4Username: username5Password: yourpassword 登入完，直接用docker push來上傳就行了: 1docker push yourusername/image_name:tag 連結Docker Hub：https://hub.docker.com/repository/docker/augustushsu/ubuntu18.04-xrdp Github：https://github.com/AugustusHsu/Docker-DL","link":"/2019/12/23/DeepLearning-03/"},{"title":"DL Machine系列-01 安裝Docker-19.03+Nvidia-docker","text":"docker安裝sudo apt-get remove docker docker-engine docker.io用來確保你的環境中沒有docker免得版本衝突，可以點這個網站下載和你作業系統相符的docker安裝檔案。我這邊下載的是19.03.5版本。 接著解壓縮跟copy到bin目錄： 1tar xzvf docker-19.03.5.tgz2sudo cp -rf docker/* /usr/local/bin/ 可以透過執行： 1docker --version2sudo docker run hello-world 來確定版本跟能否順利執行。 Nvidia Docker 確認docker版本在19.03以上 linux kernel版本大於3.10(可以透過uname -r確認) 你主機板上裝的GPU架構要在Fermi(2.1)以上(可以上Wiki查看) 還有GPU的Driver要361.93以上(可以用nvidia-smi在終端機查看) 將nvidia的資料庫加到電腦中： 1curl -s -L https://nvidia.github.io/nvidia-docker/gpgkey | \\2 sudo apt-key add -3distribution=$(. /etc/os-release;echo $ID$VERSION_ID)4curl -s -L https://nvidia.github.io/nvidia-docker/$distribution/nvidia-docker.list | \\5 sudo tee /etc/apt/sources.list.d/nvidia-docker.list6sudo apt-get update 安裝nvidia-container-toolkit： 1sudo apt-get install -y nvidia-container-toolkit 參考資料：nvidia-docker的wiki bug1-docker路徑問題因為前面安裝docker是用手動安裝的，所以docker的位置跟用sudo apt-get install docker的位置不一樣，所以有以下錯誤碼： 1Cannot connect to the Docker daemon at unix:///var/run/docker.sock. Is the docker daemon running? 接著我嘗試重新啟動docker： 1sudo systemctl restart docker2# 以下為output3Job for docker.service failed because the control process exited with error code. See \"systemctl status docker.service\" and \"journalctl -xe\" for details 要你執行systemctl status docker.service和journalctl -xe找詳細資料: 1sudo systemctl status docker.service2# 以下為output3docker.service - LSB: Create lightweight, portable, self-sufficient containers.4 Loaded: loaded (/etc/init.d/docker; generated)5 Active: failed (Result: exit-code) since Mon 2019-12-16 23:47:44 CST; 20min ago6 Docs: man:systemd-sysv-generator(8)7812月 16 23:47:44 mars systemd[1]: Starting LSB: Create lightweight, portable, self-sufficient containers....912月 16 23:47:44 mars docker[7032]: * /usr/bin/dockerd not present or not executable1012月 16 23:47:44 mars systemd[1]: docker.service: Control process exited, code=exited status=11112月 16 23:47:44 mars systemd[1]: docker.service: Failed with result 'exit-code'.1212月 16 23:47:44 mars systemd[1]: Failed to start LSB: Create lightweight, portable, self-sufficient containers.. 看到/usr/bin/dockerd，因為安裝的時候dockerd是放在/usr/local/bin/裡面，因此要更改docker.service中的設定，前往/etc/init.d/，編輯docker: 1cd /etc/init.d/2vim docker 將檔案中DOCKERD的位置改成上面手動安裝的位置： 1-DOCKERD=/usr/bin/dockerd2+DOCKERD=/usr/local/bin/dockerd 接著重啟daemon和docker.service，然後查看docker.service： 1systemctl daemon-reload &amp;&amp; systemctl restart docker.service2sudo systemctl status docker.service3# 以下為output4docker.service - LSB: Create lightweight, portable, self-sufficient containers.5 Loaded: loaded (/etc/init.d/docker; generated)6 Active: active (running) since Tue 2019-12-17 00:08:53 CST; 2s ago7 Docs: man:systemd-sysv-generator(8)8 Process: 7724 ExecStart=/etc/init.d/docker start (code=exited, status=0/SUCCESS)9 Tasks: 23 (limit: 19660)10 CGroup: /system.slice/docker.service11 └─7736 /usr/local/bin/dockerd -p /var/run/docker.pid121312月 17 00:08:53 mars systemd[1]: Starting LSB: Create lightweight, portable, self-sufficient containers....1412月 17 00:08:53 mars docker[7724]: * Starting Docker: docker1512月 17 00:08:53 mars docker[7724]: ...done.1612月 17 00:08:53 mars systemd[1]: Started LSB: Create lightweight, portable, self-sufficient containers.. 可以看到可以成功執行了～～ 接著試試看nvidia-docker： 1# Starting a GPU enabled container2$ docker run --gpus all nvidia/cuda nvidia-smi34# Start a GPU enabled container on two GPUs5$ docker run --gpus 2 nvidia/cuda nvidia-smi67# Starting a GPU enabled container on specific GPUs8$ docker run --gpus device=1,2 nvidia/cuda nvidia-smi9$ docker run --gpus device=UUID-ABCDEF,1 nvidia/cuda nvidia-smi1011# Specifying a capability (graphics, compute, ...) for my container12# Note this is rarely if ever used this way13$ docker run --gpus all,capabilities=utilities nvidia/cuda nvidia-smi 如果成功會跟你在電腦中執行nvidia-smi的結果一樣。 因為docker-19.03已經支援使用NVIDIA GPUs作為運行中的設備了。 上面指令有加上--gpu的選項，如果你不要加，可以在Dockerfile上加上： 1# 用來指定使用的gpu，和上面的--gpu相同功能2ENV NVIDIA_VISIBLE_DEVICES all3# 用來指定計算資源，跟上面寫的一樣，這個功能很少用到4ENV NVIDIA_DRIVER_CAPABILITIES compute,utility bug2-container無法stop, kill只能使用sudo systemctl restart docker來重新啟動docker，這是因為原本我安裝的是19.03.1版本，這版本有無法刪除container的問題，在網路上搜索一段時間後，有一些人也有遇到這個問題，不過是在windows版本上。 簡而言之就是因為一些deadlock導致容器的API沒有任何回應，也就是無法stop,kill的問題。 後來在github上看到有人說19.03.5也就是最新版本，解決了deadlocks的問題，果斷更新，更換/usr/local/內所有從docker-19.03.1.tgz解壓縮的檔案，再重開機就沒有這個問題了。","link":"/2019/12/18/DeepLearning-01/"},{"title":"DL Machine系列-02 建立LVM管理儲存空間","text":"前言這台硬碟上裝了5顆硬碟(2顆2.5’ SSD、2顆3.5’ HDD、1顆m.2 SSD)，因為我們實驗室處理的資料量都頗大，動不動就500GB-1TB，如果單純地根據硬碟分開儲存的話，可能會浪費很多剩餘空間，而且在跑資料的時候可能會產生其他資料，這又導致不能預先切割硬碟來符合檔案大小(而且很麻煩)，為了方便合理的利用所有硬碟空間，我決定將硬碟整合起來一起管理。 在找合適的硬碟管理方法的時候，有想過組一個RAID 0的磁碟陣列，不過考慮到之後的擴充需求加上實驗室已經有一台NAS來儲存資料，不需要太擔心資料的完整性，所以查到了LVM的方法來管理資料儲存。 LVM介紹LVM是 Logical Volume Manager(邏輯卷管理)的簡寫，LVM會將一個或多個硬碟的分區在邏輯上集合，可以直接把它當作一顆大硬碟來用，當硬碟空間不足的時候，可以從剩餘空間上劃分一些空間給其他空間不夠的分區使用。 簡單地以一張圖來表示： 不過我這邊只是打算單純地以SSD和HDD兩種不同的硬碟來組成LVM，分別管理讀寫速率不一樣的兩種硬碟。 名詞介紹PV：Physical Volume，物理的磁碟分區，也就是硬碟上的分區，分區要變成PV後，LVM才能利用那個分區。 VG：Volume Group，將所有PV加入VG整合起來，可以理解成一個倉庫或是幾個大的硬碟。 LV：Logical Volume，從VG中劃分空間分配給LV，會建立一個裝置代號放在系統中，即最後被掛載道系統的分區。 經過PV、VG規劃後，可以理解成，把分區整合成一個大的硬碟，再利用這顆硬碟來分割分區或是格式化，不過這顆大硬碟可以增加或是減少分區的容量，而且原本的資料不會受到影響。 LVM建立流程 建立硬碟分區，這裏因為只是想要單純的分成SSD和HDD，所以就直接把整顆硬碟當作一顆分區來建立，格式化的時候記得使用lvm2的格式(在fdisk中編號為8e)。 創建VG，將前面所創立的PV加入到VG中，VG命名建議以vg開頭，這樣容易辨識出這是一個VG。 創建LV，直接設定容量到你要創建的空間，再掛載到系統就行了。 簡單的三個步驟就可以完成創建LVM了，下面以圖示來說明： [實作]LVM硬碟整合先用之前裝過的Gparted把要加入的硬碟全部格式化為lvm2 pv，如果是新硬碟記得要先新增分割表。 另外記得選擇完後Gparted還不會幫你格式化，要記得點選上面的綠色勾勾，才會應用你的配置。 接下來建立VG，這裡我們直接把HDD跟SSD兩個VG創建出來： 1sudo vgcreate vgHDD /dev/sda1 /dev/sdb12sudo vgcreate vgSSD /dev/sda1 /dev/sdb1 這樣我們就創立好兩個VG了，如果要添加新的PV可以使用： 1sudo vgextend YourVG /dev/NewPVDisk 對VG來切割LV出來，這邊使用所有空間，然後用lvdisplay來查看資訊： 1sudo lvcreate -l 100%FREE -n HDD vgHDD2sudo lvcreate -l 100%FREE -n SSD vgSSD3sudo lvdisplay4# output15LV Path /dev/vgHDD/HDD6LV Name HDD7VG Name vgHDD8# output29LV Path /dev/vgSSD/SSD10LV Name SSD11VG Name vgSSD 格式化HDD這個LV，再掛載到需要的位置，這邊用mkfs用xfs的格式來格式化硬碟，要使用mkfs.xfs要記得先安裝xfsprogs： 1sudo apt-get install xfsprogs2sudo mkfs.xfs /dev/vgHDD/HDD3sudo mkfs.xfs /dev/vgSSD/SSD 接下來掛載到/mnt，這邊放在/mnt裡面統一管理： 1sudo mkdir /mnt/HDD /mnt/SSD2sudo mount /dev/vgHDD/HDD /mnt/HDD3sudo mount /dev/vgSSD/SSD /mnt/SSD 管理LVM在網路上找到這張圖： 使用方法就是(PV, VG, LV) + 左邊的指令： 1# 查看所有LVM的PV2sudo pvs3# 查看更詳細的資訊4sudo pvdisplay 另外如果以後新增了更多硬碟，也可以透過lvcreate來組成RAID1, RAID5, RAID6。 補充因為之前硬碟放在其他系統上運作，所以上面有一些預設的磁區，我發現上面有些詞曲沒刪乾淨，所以遇到了下面這個狀況，硬碟是HDD的硬碟： 看了很討厭，所以就進行了更改： 1# 卸載之前掛載的PV2sudo umount /dev/vgHDD/HDD3# 刪除LV4sudo lvremove vgHDD/HDD5# 轉移資料，將/dev/sda1裡的資料轉移出去6sudo pvmove /dev/sda17# 從VG中移除PV8sudo vgreduce vgHDD /dev/sda1 這時候你可以透過Gparted或是用lvm的指令來建立新的lvm分區，再來將新的分區添加到vgHDD中： 1sudo vgextend vgHDD /dev/sda1 接下來重複上面的格式化跟掛載步驟就行。","link":"/2019/12/19/DeepLearning-02/"},{"title":"hexo系列-00 hexo簡介＆環境安裝","text":"A fast, simple &amp; powerful blog framework 前言一直以來就有想要架設個人網站的想法，之前在學寫HTML的時候，有試過用github.io的功能，他可以直接把你寫的網頁直接呈現在外部ip。(在大學的時候有想過用這個功能把專題直接讓每個人玩，不過後來發現，他只能用靜態網頁所以後來就不了了之。) 身為一個懶惰又想要讓自己的網站很炫能看的資訊工程學生，在一看到hexo這個工具，就立刻架設了一個範本，也就是現在你所看到的這個網站，經過研究一段時間後發現，架設這個網站只需要簡單的幾個指令就可以完成，基本上不需要資訊工程或是有編程經驗的背景就可以使用了。 不過要注意的是hexo是一個基於Node.js的靜態blog工具，可以很方便的將生成的網頁直接放在Github上面，不過要注意的是他跟基於PHP的WordPress不一樣，如果你想搭建功能比較複雜的網頁或是WebAPP的話，還是採用動態網站比較好。 之後會慢慢的完善這個網頁，接下來就直接開始介紹怎麼使用hexo這個工具吧～ 環境安裝、配置NodeJS/NPMNodeJS是能夠在電腦運行JavaScript的開放原始碼，幾本上所有在寫前端的程序猿都會需要使用，安裝方法很簡單，去NodeJS官方網站下載一個LTS的版本就可以了，如果你電腦安裝過了就可以直接跳過。 有許多人在JavaScript上發佈、使用許多模塊，要調用也十分容易，其中NPM是最有名的社群，也是國際上最為流行的Node模塊管理工具，現在的NodeJS已經集成了NPM，所以不需要再去安裝。 Git/Github去Git官網下載和自己作業系統相對應的安裝包，另外如果沒有Github帳戶的人也需要去申請一個。 另外要記得設定全局變量還有ssh-key 1git config --global user.name \"Your Github username\"2git config --global user.email \"Your Github mail address\"3ssh-keygen -t rsa -C \"Your Github mail address\" 然後可以在家目錄~/裡面看到.ssh文件夾，在裡面會有id_rsa.pub這個檔案，可以使用pbcopy這個指令來複製key。 1pbcopy &lt; ~/.ssh/id_rsa.pub 然後到Github SSH and GPG keys新增你的key，標題隨意打一個就行，新增完後以後要發文就不需要再輸入Github的密碼了。 Hexohexo可以直接使用npm來進行安裝： 1npm install hexo-cli -g 到這邊基本的環境就算安裝完成。 進入你要創建hexo的目錄(建議創建的目錄為XXX.github.io)，接下來初始化hexo的環境： 1hexo init XXX.github.io2cd XXX.github.io3npm install4hexo server 到這個步驟你就可以直接用瀏覽器打開localhost:4000(默認的port，也可以用hexo server -p XXXX來指定你的連接埠)，預設的主題是landscape。 到這裡你就可以開始使用你個人的blog了，下一篇會介紹如何更改主題、上傳到Github Page等等。 Hexo建置在使用的hexo之前，我想各位都已經找到自己感興趣的網站樣板了吧？！(至少我是XD) 如果還沒有開始找想要的樣板也沒關係，這裏列出了很多不同的樣板可以去參考看看。 主題安裝這裡我挑選的是Icarus作為我的主題，然後直接在~/XXX.github.io這個目錄下面輸入： 1git clone https://github.com/ppoffice/hexo-theme-icarus.git themes/icarus 這樣就可以直接把主題安裝到目錄中的themes資料夾了。 如果在這之前你是使用過hexo的人要轉換主題，你要先執行： 1hexo clean 清除之前主題渲染過內容的檔案，再重新渲染一次才不會有問題。 設置文件在執行完上面步驟之後，你會在資料夾發現兩個_config.yml，一個在XXX.github.io資料夾內，另一個在剛剛下載的主題內。 接下來將XXX.github.io內的_config.yml打開，將theme改寫成你主題的名字： 1theme: icarus 接著執行選染的指令： 1hexo generate2hexo g #簡寫當然也是可以的 最後就可以在瀏覽器看結果囉～ 1hexo server 預設地址為：http://localhost:4000 新增貼文接下來是新增貼文，在目錄中使用下面這個指令就可以新增貼文了： 1hexo new post 'title' 然後在XXX.github.io/source/_posts/這資料夾內就會看到剛剛新增的title.md檔案，文章標題默認會和檔案名稱一樣，打開這個md檔長得像這樣： 1---2title: title3date: 2019-12-10 15:05:404tags:5--- 這邊就是單純的Markdown語法，無須多說。不過在頂部的設定區有一些有趣的選項，譬如tag, categories, thumbnail, toc，其中thumbnail和toc分別代表的是縮圖跟目錄，可以用以下的方式設定： 1---2title: title3date: 2019-12-10 15:05:404tags: [A,B]5categories: C6thumbnail: /uploads/YourImage.JPG7toc: true8--- 這邊要注意的是圖片的位置，這邊個人建議是在XXX.github.io/public/裡面新增一個資料夾叫做uploads，之後你文章中所使用的任何圖片都可以上傳到這裡在用/uploads/YourImage.JPG的方式指定到目標位置。 當然如果你要建立子資料夾來管理圖片也是可以的，之後文章會介紹post_asset_folder讓圖片可以放在_posts裡面，用文章的名稱來管理用到的圖片。 上傳到Github前面有申請過Github的帳戶，現在我們要將網站發佈在Github Page上面，首先要做的是打開XXX.github.io下的_config.yml檔案，找到Deployment將其改成像下面這段： 1# Deployment2## Docs: https://hexo.io/docs/deployment.html3deploy:4 type: 'git'5 repo: https://github.com/YourAccount/XXX.github.io.git6 branch: master7 message: 變更成你的配置，不過不建議在message加上內容，我們可以在後面加上message的訊息，記得要先generate才可以上傳到你的Github帳戶： 1hexo generate2hexo depoly -m \"github message\" 建議在這裡加上附註，因為可以使用一些git的技巧，直接在-m後面加上要傳上去的附註，當然也可以將上傳的時間點加在附註上面，像是這樣的形式： 1hexo d -m \"Site updated: `date +'%Y-%m-%d %H:%M:%S'`\" 結語以上就是關於hexo的基本操作方式，接下來會針對_config.yml檔案裡面的參數去做介紹。","link":"/2019/12/09/hexo-00/"},{"title":"hexo系列-01 hexo簡單配置","text":"theme下的_config.yml前面有介紹過hexo在生成主題之後會有兩個_config.yml，這邊著重介紹在theme中的設定(絕對不是hexo原生的_config.yml沒什麼好介紹的) favicon&amp;logo首先就是favorites icon和logo~ 你可以在_config.yml裡面找到： 1# Path or URL to the website's icon23favicon: /images/favicon.png45# Path or URL to the website's logo to be shown on the left of the navigation bar or footer67logo: /images/logo.png 然後打開你的目錄XXX.github.io/public/images/裡面找到相對應的圖檔，間單的替換+更改檔名就可以放上你想要的圖片囉～ share分享的方式Icarus提供了許多方式，預設是： 1# Share2share: default # options: jiathis, bdshare, addtoany, default 這邊我使用的是AddThis在連結中註冊帳戶，他可以透過google, Facebook或是Twitter註冊帳戶，這個網站不只有分享按鈕的JavaScript，詳細功能可以自行去探索，設定好後會得到像是這樣的code 1//s7.addthis.com/js/300/addthis_widget.js#pubid=xxxxxxxx 將share那段替換成： 1# Share2share:3 type: addthis4 install_url: //s7.addthis.com/js/300/addthis_widget.js#pubid=xxxxxxxx # (required) 如此就可以直接在你的post上面看到我頁面上的分享按鈕了～ Donate當你建置好你的網站後你可能會發現下面這樣的狀況： 這是因為你在Donate的選項中沒有設置完全，直接把它註解掉就可以解決這個問題了。 1# donate:2 # -3 # # Donation entry name4 # type: alipay5 # # Qrcode image URL6 # qrcode: ''7 # -8 # # Donation entry name9 # type: wechat10 # # Qrcode image URL11 # qrcode: ''12 # -13 # # Donation entry name14 # type: paypal15 # # Paypal business ID or email address16 # business: 'V6DFAWSEDJJHE'17 # # Currency code18 # currency_code: U19 # -20 # # Donation entry name21 # type: patreon22 # # URL to the Patreon page23 # url: '' 當然如果你要設置Donate的帳戶也完全沒問題😜 highlight接著是highlight選項，這個是程式碼區塊的顯示格式，可以透過這裡去預覽、這裡去下載。 簡單的將highlight名稱替換成你想要的樣板名稱就可以裡： 1# Code highlight settings2highlight: 3 # Code highlight themes4 # https://github.com/highlightjs/highlight.js/tree/master/src/styles5 theme: zenburn6 # Show code copying button7 clipboard: true8 # Default folding status of the code blocks. Can be \"\", \"folded\", \"unfolded\"9 fold: unfolded 這裏我選擇的是zenburn，理由就是我覺得好看這個暗色主題黑的剛剛好，不會想其他主題一樣太黑，或者是不夠黑。 widgets這個選項就是調整你在頁面上所看到所有一塊塊區域的內容跟功能，第一個區塊就是網頁簡單名片： 在_config.yml的widgets第一個區塊就是相關的設定，包含像是位置、作者、還有圖片等等。在預設中沒有的是Envelope選項，也就是上面那張圖的右下角，可以通過更改social_links來將你的信箱新增上去： 1social_links:2 Github:3 icon: fab fa-github4 url: 'https://github.com/AugustusHsu'5 Facebook:6 icon: fab fa-facebook7 url: 'https://www.facebook.com/HsuAugustus'8 Envelope:9 icon: fas fa-envelope10 url: mailto:jimhsu11@gmail.com 這樣設置後，只要點擊你的信箱那個圖示，電腦會自動跳到寫信的應用程式(不過這年代還有誰會用Email來寫信😆) 其他功能我都是使用預設選項，當然其中會有像是： 1position: left 這樣的選項，你可以自行調整要放在左右那一邊，當然你也可以直接註解掉整塊來取消這個功能。 Image管理在Hexo你的發文可以透過MarkDown語法來編寫，所以在引用圖片的時候是可以透過第三方的網站來上傳圖片，再利用： 1！[title](image link) 來展示你的圖片，那如果想要將圖片放在你的網頁資料夾中的話，要怎麼引用呢？ hexo-asset-image這邊可以直接安裝這個插件，在新增貼文的時候會同時產生一個同名的資料夾，把圖片丟進資料夾再飲用就可以了。 在XXX.github.io資料夾輸入以下命令： 1npm install hexo-asset-image --save 另外在XXX.github.io中的_config.yml： 1post_asset_folder: true 將它改成true，這樣在新增貼文的時候就會自動產生同名的資料夾了。 實際運用如果你的圖片放在同名資料夾的話，在文章中要引用圖片的話，要像下面這個例子一樣： 1！[title](image_name.jpg) 無需加上資料夾的名稱，直接打你的圖片檔名就可以引用了。 不過這邊要注意的是如果你這樣打，在MarkDown編輯器中，你圖片會看不到，還有如果你是一邊啟動hexo server在編輯的話，你在網頁上圖片也是會顯示不出來，要執行過一次： 1hexo g 才能正常的在localhost:4000中看到圖片。 留言設置文章當然免不了討論問題，那在文章底部新增一個互動機制也就是留言功能，就在所難免。 在這個留言設置中，我只舉出兩種我有實際操作過的方法，其他像是gitment在Icarus列出的方法就請有興趣的朋友自行研究了。 gitalkgitalk是使用github上面的issue功能實現的留言討論功能，所以要跟github做連結。 OAuth OAuth是一個開放標準，允許用戶讓第三方應用存取該用戶在某一網站上儲存的私密的資源，而無需將用戶名稱和密碼提供給第三方應用。 –Wiki 也就是要授權github來儲存對話紀錄，點擊這裡來申請一個OAuth 其中Homepage URL跟Authorization callback URL請填你github.io的網址，name就簡單填個就行。 申請完會得到Client ID跟Client Secret將這兩項填入： 1comment:2 type: gitalk3 owner: xxxxxxxx # (required) GitHub user name4 repo: xxxxxxxx # (required) GitHub repository name5 client_id: xxxxxxxx # (required) OAuth application client id6 client_secret: xxxxxxxx # (required) OAuth application client secret7 admin: xxxxxxxx # (required) GitHub repo owner and collaborators who can initialize github issues8 # Can either be a string or an array.9 # admin:10 # - xxxxxx111 # - xxxxxx2 owner跟admin就直接填你github帳戶名稱就行。 一開始你可能會遇到像是這樣： 這時候直接按下去就會要你去登入並授權這個應用功能： 結束後你就可以在文章下方看到跟我一樣的留言區塊了。 facebookfacebook的話比較簡單，不過我之前有遇到過他的寬度不太合的狀況，所以比較推薦使用gitalk的方式來增加留言功能。 facebook的方式一樣要先授權，所以點這裡將你github.io的網址填入，接著按下取得程式碼就可以了。 再來要在_config.yml裡面把comment的設定更改成facebook: 1comment:2 type: facebook 這樣就設定完成了。 補充你在首頁看到我的文章會看到Read More這個框框，這個是MarkDown的語法，直接在你想隱藏的段落前加上： 1&lt;!--more--&gt; 就可以摺疊你的貼文了。","link":"/2019/12/10/hexo-01/"},{"title":"hexo系列-02 hexo個人化設置","text":"前言在用主題模板的時候，總有些時候會覺得網頁版面怪怪的、不盡人意的地方，那要怎麼改呢？ 這邊列出了我對Icarus主題的改動地方，這篇的東西都是參考下列網址： https://www.alphalxy.com/2019/03/customize-icarus https://dp2px.com/2019/06/04/icarus-theme/ https://github.com/ppoffice/hexo-theme-icarus/issues/379 然後我這邊不是全部採用，而是選取部分內容時做到我的網站上，不過話說前頭，本人不是專業的前端工程師，所以大部分內容都只是參考一下就直接照抄，如果對本文內容不夠滿意的話，建議可以直接去看上面的網址內容。 佈局Icarus的主題默認上是三欄式網頁佈局，不過這個模式在瀏覽文章的時候總會覺得版面有些太滿，所以這邊我將閱讀文章的佈局改成兩欄式的佈局。 文章佈局-兩欄式佈局打開includes/helpers/layout.js找到下面紅字那行替換成綠字那行，記得不要複製到+號： 1const widgets = hexo.extend.helper.get('get_config').bind(this)('widgets');2- return widgets.filter(widget =&gt; widget.hasOwnProperty('position') &amp;&amp; widget.position === position);3+ if (this.page.layout !== 'post') {4+ return widgets.filter(widget =&gt; widget.hasOwnProperty('position') &amp;&amp; widget.position === position);5+ }6+ if (position === 'left') {7+ return widgets.filter(widget =&gt; widget.hasOwnProperty('position') &amp;&amp; (widget.type === 'toc' || widget.type === 'profile'));8+ } else {9+ return []10+ } 這邊可以注意到page.layout是頁面的類型，當他是'post'時代表當前是文章閱讀的模式，當然你也可以針對其他頁面去做調整，像是index代表首頁、tag代表標籤頁。 詳細的網頁類別可以點這裡查到。 if (position === 'left')這段代表的是小工具載入的位置，你也可以設定成'right'來讓你後續要載入的小工具展是在右邊。 後面的widget.type代表的是要列在上面指定位置的小工具，可以透過||來增加你想展示的小工具。 接下來因為兩籃式佈局跟三欄式佈局整體的寬度不一樣，所以要調整layout/common/widget.ejs這個檔案： 1&lt;% function side_column_class() {2 switch (column_count()) {3 case 2:4- return 'is-4-tablet is-4-desktop is-4-widescreen';5+ return 'is-4-tablet is-4-desktop is-3-widescreen';6 case 3: 還有這個檔案layout/layout.ejs： 1-&lt;body class=\"is-&lt;%= column_count() %&gt;-column\"&gt;2+&lt;body class=\"is-3-column\"&gt;3 &lt;%- partial('common/navbar', { page }) %&gt;4 &lt;% function main_column_class() {5 switch (column_count()) {6 case 1:7 return 'is-12';8 case 2:9- return 'is-8-tablet is-8-desktop is-8-widescreen';10+ return 'is-8-tablet is-8-desktop is-9-widescreen'; 因為Icarus有針對響應式去做設計，所以要更改source/css/style.styl，針對不同螢幕寬度有相應的呈現： 1 .is-2-column .container2 max-width: screen-desktop - 2 * gap3 width: screen-desktop - 2 * gap4+ .is-3-column .container5+ max-width: screen-widescreen - gap6+ width: screen-widescreen - gap7 @media screen and (min-width: screen-fullhd)8+ .is-3-column .container9+ max-width: screen-fullhd - 2 * gap10+ width: screen-fullhd - 2 * gap11 .is-2-column .container12 max-width: screen-widescreen - 2 * gap13 width: screen-widescreen - 2 * gap 標題佈局-更新時間和icon接下來新增文章標題的更新時間和標籤icon，更改layout/common/article.ejs： 1 &lt;% if (post.layout != 'page') { %&gt;2 &lt;div class=\"level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto\"&gt;3 &lt;div class=\"level-left\"&gt;4- &lt;time class=\"level-item has-text-grey\" datetime=\"&lt;%= date_xml(post.date) %&gt;\"&gt;&lt;%= date(post.date) %&gt;&lt;/time&gt;5+ &lt;time class=\"level-item has-text-grey\" datetime=\"&lt;%= date_xml(post.date) %&gt;\"&gt;&lt;i class=\"far fa-calendar-alt\"&gt;&amp;nbsp;&lt;/i&gt;&lt;%= date(post.date) %&gt;&lt;/time&gt;6+ &lt;% if (post.updated &amp;&amp; post.updated &gt; post.date) { %&gt;7+ &lt;time class=\"level-item has-text-grey is-hidden-mobile\" datetime=\"&lt;%= date_xml(post.updated) %&gt;\"&gt;&lt;i class=\"far fa-calendar-check\"&gt;&amp;nbsp;&lt;/i&gt;&lt;%= date(post.updated) %&gt;&lt;/time&gt;8+ &lt;% } %&gt;9 &lt;% if (post.categories &amp;&amp; post.categories.length) { %&gt; 然後要刪除source/js/main.js中的部分程式碼： 1- if (typeof(moment) === 'function') {2- $('.article-meta time').each(function () {3- $(this).text(moment($(this).attr('datetime')).fromNow());4- });5- } 我這邊遇到了一個問題：在source/js/main.js找不到上面那段刪除，這邊猜測是要執行hexo g之後才會產生上面那段程式碼，如果找不到要刪除的程式碼，記得要去generate一次你的網站。 完成的模樣會像是這樣的狀況： 文章結尾佈局-修改tag展示這邊在文章底部增加了一個hr，然後針對文章的預覽還有結尾加上了tag的icon，修改layout/common/article.ejs這個檔案： 1 &lt;% if (!index &amp;&amp; post.tags &amp;&amp; post.tags.length) { %&gt;2+ &lt;hr style=\"height:1px;margin:1rem 0\"/&gt;3 &lt;div class=\"level is-size-7 is-uppercase\"&gt;4 &lt;div class=\"level-start\"&gt;5 &lt;div class=\"level-item\"&gt;6- &lt;span class=\"is-size-6 has-text-grey has-mr-7\"&gt;#&lt;/span&gt;7+ &lt;i class=\"fas fa-tags has-text-grey\"&gt;&lt;/i&gt;&amp;nbsp;8 &lt;%- list_tags(post.tags, {9 class: 'has-link-grey ',10 show_count: false,11- style: 'link'12+ style: 'link',13+ separator: ',&amp;nbsp;'14 }) %&gt;15 &lt;/div&gt;16 &lt;/div&gt;17 &lt;/div&gt;18 &lt;% } %&gt;19 &lt;% if (index &amp;&amp; post.excerpt) { %&gt;20- &lt;div class=\"level is-mobile\"&gt;21+ &lt;hr style=\"height:1px;margin:1rem 0\"/&gt;22+ &lt;div class=\"level is-mobile is-flex\"&gt;23+ &lt;div class=\"level-start\"&gt;24+ &lt;% if (post.tags &amp;&amp; post.tags.length) { %&gt;25+ &lt;div class=\"level-item is-size-7 is-uppercase\"&gt;26+ &lt;i class=\"fas fa-tags has-text-grey\"&gt;&lt;/i&gt;&amp;nbsp;27+ &lt;%- list_tags(post.tags, {28+ class: 'has-link-grey ',29+ show_count: false,30+ style: 'link',31+ separator: ',&amp;nbsp;'32+ }) %&gt;33+ &lt;/div&gt;34+ &lt;% } %&gt;35+ &lt;/div&gt;36 &lt;div class=\"level-start\"&gt; 手機顯示優化在使用手機瀏覽網站的時候，隱藏archive和tagcloud小工具，修改layout/widget/archive.ejs： 1-&lt;div class=\"card widget\"&gt;2+&lt;div class=\"card widget is-hidden-mobile\"&gt; layout/widget/tagcloud.ejs： 1-&lt;div class=\"card widget\"&gt;2+&lt;div class=\"card widget is-hidden-mobile\"&gt; 當然，你可以在layout/widget/裡面找你想要隱藏的小工具，一樣套用上面的方式。 固定目錄將文章的目錄固定在一個位置，不會隨著網頁的滾動而看不到目錄，這邊只需簡單的修改layout/widget/toc.ejs就可以了： 1-&lt;div class=\"card widget\" id=\"toc\"&gt;2+&lt;div class=\"card widget column-left is-sticky\" id=\"toc\"&gt; 功能接下來針對網頁的功能去做新增跟修正。 版權宣告在layout/common/article.ejs新增： 1 &lt;div class=\"content\"&gt;2 &lt;%- index &amp;&amp; post.excerpt ? post.excerpt : post.content %&gt;3 &lt;/div&gt;4+ &lt;% if (!index &amp;&amp; post.layout === 'post' &amp;&amp; post.copyright !== false) { %&gt;5+ &lt;ul class=\"post-copyright\"&gt;6+ &lt;li&gt;&lt;strong&gt;文章標題：&lt;/strong&gt;&lt;a href=\"&lt;%= post.permalink %&gt;\"&gt;&lt;%= page.title %&gt;&lt;/a&gt;&lt;/li&gt;7+ &lt;li&gt;&lt;strong&gt;文章作者：&lt;/strong&gt;&lt;a href=\"&lt;%= theme.url %&gt;\"&gt;&lt;%= theme.author %&gt;&lt;/a&gt;&lt;/li&gt;8+ &lt;li&gt;&lt;strong&gt;文章連結：&lt;/strong&gt;&lt;a href=\"&lt;%= post.permalink %&gt;\"&gt;&lt;%= post.permalink %&gt;&lt;/a&gt;&lt;/li&gt;9+ &lt;li&gt;&lt;strong&gt;發佈時間：&lt;/strong&gt;&lt;%= post.date.format(\"YYYY-MM-DD\") %&gt;&lt;/li&gt;10+ &lt;li&gt;&lt;strong&gt;版權聲明：&lt;/strong&gt;本博客所有文章除特別聲明外，均採用 &lt;a href=\"https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh\" rel=\"external nofollow\" target=\"_blank\"&gt;CC BY-NC-SA 4.0&lt;/a&gt; 許可協議。引用請註明出處！11+ &lt;/li&gt;12+ &lt;/ul&gt;13+ &lt;% } %&gt;14 &lt;% if (!index &amp;&amp; post.tags &amp;&amp; post.tags.length) { %&gt; 然後增加css樣式，在source/css/style.styl新增： 1/* ---------------------------------2 * Copyright3 * --------------------------------- */4+.post-copyright5+ font-size: 1rem6+ letter-spacing: 0.02rem7+ word-break: break-all8+ margin: 2.5rem 0 09+ padding: 1rem 1rem10+ border-left: 3px solid #FF170011+ background-color: #F9F9F9 默認使用目錄小工具正常在寫文章的時候，要啟用目錄的功能時，需要在meta資料中加入toc: true來開啟目錄小工具，不過大多數時候都會在文章中使用目錄，所以這邊讓他在默認的時候加入toc: true，修改includes/helpers/config.js： 1 return defaultValue;2 } else {3 const property = readProperty(specs, configName);4- return property === null ? null : property[descriptors.defaultValue];5+ const result = property === null ? null : property[descriptors.defaultValue];6+ return (configName === 'toc' &amp;&amp; this.page.layout === 'post' &amp;&amp; result === null) ? true : result;7 } footer顯示一組icon在版權的地方有寫到採用CC BY-NC-SA 4.0，而CC BY-NC-SA 4.0的icon是四個一組，所以要讓在配置link.icon可以是一個數組的方式呈現。 修改layout/common/footer.ejs： 1 &lt;% } else { %&gt;2- &lt;i class=\"&lt;%= link.icon %&gt;\"&gt;&lt;/i&gt;3+ &lt;% for (let icon of (Array.isArray(link.icon) ? link.icon : [link.icon])) { %&gt;&lt;i class=\"&lt;%= icon %&gt;\"&gt;&lt;/i&gt;&amp;nbsp;&lt;% } %&gt;4 &lt;% } %&gt; 和includes/specs/icon_link.spec.js： 1 icon: {2 [required]: true,3- [type]: 'string',4+ [type]: ['string', 'array'],5 [doc]: 'Link icon class names' 另外在_config.yml中修改成這樣： 1footer:2 links:3 CC BY-NC-SA 4.0:4 icon:5 - fab fa-creative-commons6 - fab fa-creative-commons-by7 - fab fa-creative-commons-nc8 - fab fa-creative-commons-sa9 url: 'https://creativecommons.org/licenses/by-nc-sa/4.0/' 樣式按鈕、背景顏色增加漸變讓一些按鈕(例如profile中的文章、分類等)有陰影、漸變的效果，修改source/css/style.styl： 1 .menu-list li ul2 margin-right: 03+ .menu-list a4+ transition: background-color 0.3s ease-in-out5 .menu-list a.level6 display: flex 區塊增加浮動效果:hover時曾大陰影面積，增加動畫屬性ease-in-out，修改source/css/style.styl： 1 .card2 border-radius: 4px3 box-shadow: 0 4px 10px rgba(0,0,0,0.05), 0 0 1px rgba(0,0,0,0.1)4+ &amp;:hover5+ box-shadow: 0 6px 15px rgba(0,0,0,0.15), 0 0 1px rgba(0,0,0,0.1) 還有source/js/animation.js： 1 element.style.transform = '';2- element.style.transition = 'opacity 0.3s ease-out, transform 0.3s ease-out';3+ element.style.transition = 'opacity 0.3s ease-out, transform 0.3s ease-out, box-shadow 0.3s ease-in-out'; 這樣修改能看到在滑鼠移到各個區塊的時候會有淡淡的陰影，可以更改上面數值讓他變得明顯或是淡化它。 結語這篇是參考alphalxy這個網站上面的設置(並不是全都採用)，我在最上面也有留這個網站的連結，實作完之後版面的規劃跟細節，讓觀看的舒適度大大的增加也讓我比較順眼了。 如果你有找到更好的設置，歡迎留言給我，之後如果有其他有趣的功能會在實作後分享上來～","link":"/2019/12/11/hexo-02/"},{"title":"hexo系列-03 讓google可以搜尋到你的網站","text":"前言原本以為要讓自己的網站在網路上可以被搜尋到，只要能用網址打開網站，之後Google搜尋引擎就可以搜尋到相對應的內容，沒有想到事情不是那麼簡單的我還是太年輕了。 要讓搜尋引擎能搜到自己的網站，首先要去Google網站管理員的Google Search Console提交網站的一些設定，詳細的會在下面一一列出。 安裝sitemap套件1npm install hexo-generator-sitemap --save 安裝這個套件會直接幫你生成需要的檔案，接著在theme/_config.yml加上下面這段： 1#Sitemap2sitemap:3 path: sitemap.xml 接下來用： 1hexo g 生成sitemap.xml的檔案，位於XXX.github.io/public/中。 創建robots.txt在XXX.github.io/source中創建robots.txt文件： 1# hexo robots.txt2User-agent: *3Allow: /4Allow: /archives/5Allow: /categories/6Allow: /tags/7Allow: /about/ 89# Disallow: /js/10# Disallow: /css/11# Disallow: /fancybox/1213Sitemap: https://augustushsu.github.io/sitemap.xml robots.txt是用來告訴網路搜尋引擎的漫遊器(又稱網路蜘蛛)，此網站中的哪些內容是不應被搜尋引擎的漫遊器取得的，哪些是可以被漫遊器取得的。 其中Allow後面加的就是你的menu，也就是允許漫遊器搜尋的到網頁，而Disallow則相反。 你可以將在測試的網頁資料夾寫在Disallow上，這樣一些漫遊器就不會去搜到你不想公開的網頁囉，詳細的說明可以參考Googel文件，還有這篇文章。 Google Search Console前面有說要讓Google搜尋的到你需要在Google Search Console中填寫關於你訊息，登入Google帳戶後，你應該會看到這樣的畫面： 輸入你Github上的網址，之後會要你去驗證： 這邊選擇的是用HTML標記，將google提供的html程式碼複製到XXX.github.io/themes/icarus/layout/common/head.ejs，直接加在最上面就可以： 接著上傳到GitHub： 1hexo -g d 按下驗證，如果設置的正確，就會跳出以下畫面： 接下來要將剛剛建的sitemap.xml提交到Google Search Console： 驗證之後，Google會花一些時間將你的網站建檔，等過了一天你就可以用Google Search Console來分析自己的網頁囉～ robots.txt點選網址審查把你的網頁貼上，會顯示正在從 Google 索引擷取資料完成後，點選查看以檢索的網頁再點更多資訊就可以看到前面Disallow不想讓其他人看到的部分了： Google Analytics打開Google Analytics網站，註冊一個帳號，然後點選追蹤程式碼，複製你的追蹤ID，形式大概是UA-XXXXXXXX-X。 將上面的ID輸入到Icarus下_config.yml檔案中的： 1google-analytics:2 # Google Analytics tracking id3 tracking_id: UA-XXXXXXXX-X 最後再將你的成品上傳到Github就完成囉～ 1hexo -g d","link":"/2019/12/14/hexo-03/"},{"title":"DL Machine系列-04 Docker Hub Automated Build","text":"Docker Hub Automated BuildsAutomated Builds是Docker Hub上提供的功能，它可以在你Github上有更新的時候，自動地幫你Build你的Dockerfile，產生一個新的Image。 連結Github點選頭像可以看到Account Setting：再點選Linked Accounts，跟你的Github做連結：連結完會像這樣： 點選你要連結的Docker Repository，接著點選Build： 再來點選Configure Automated Builds： 可以看到你帳號的右邊可以選擇你要連結的Github Repository： 在Configure Automated Builds下面有一些設定可以調整，可以設定不同branch有不同的tag可以設定，它有舉一些例子、還有命名規則可以去查看。 Docker Hub Build Error在Docker Hub的時候，會看到下面這個狀況： 1...returned a non-zero code: 2 後來經過測試發現，這是因為我有使用ARG這個參數導致的，因為在Build你的Docker Image的時候會需要加上這些參數： 1sudo docker build -t image_name:tag \\2--build-arg USERNAME=username \\3--build-arg USERPWD=yourpassword . 雖然說在Docker Hub上面有： BUILD ENVIRONMENT VARIABLES 可以調整，不過我當時怎麼調整都會有問題。 所以後來我直接將Dockerfile加上預設值： 1-ARG USERNAME2-ARG USERPWD3+ARG USERNAME=username4+ARG USERPWD=yourpassword 這樣就可以成功Automated Build你的Dockerfile了。","link":"/2019/12/27/DeepLearning-04/"},{"title":"Machine Learning-01 Triplet Loss with Different Embedding","text":"Triplet LossTriplet Loss的介紹，相信在網路上已經有許多例子了，用途跟作用這邊就不多作介紹，直接進入正題。Triplet一開始是用來處理相同模態的資料，這邊測試用兩種模態的資料來算Triplet Loss，使用numpy來實現，後面會附上Tensorflow 2.x的代碼。 Sample Data首先要先Sample出兩個不同的Embedding資料，直接使用numpy的random來產生兩個隨機的Embedding。這邊設定Batch Size是64、每筆資料的維度為1024、Margin設定為0.3、另外Label這邊設定是每筆都是獨立的資料，所以每一筆資料對應一個label： 1import numpy as np23batch = 644emb_dim = 102456np.random.seed(1234)7emb1 = np.random.rand(batch,emb_dim).astype(np.float32)8np.random.seed(2345)9emb2 = np.random.rand(batch,emb_dim).astype(np.float32)10margin = 0.311labels = np.arange(batch) Batch All針對一個batch所有的資料計算，anchor到positive跟anchor到negative之間的距離。 Distance Metric這裡計算每一筆x對應到每一筆y的距離，回傳的是一個shape=(batch, batch)的metric： 1def _distance_metric(x, y):2 \"\"\"3 Args:4 x: tensor, with shape [m, d], (batch_size, d)5 y: tensor, with shape [n, d], (batch_size, d)6 Returns:7 dist: tensor, with shape [m, n], (batch_size, batch_size)8 \"\"\"9 # |x-y|^2 = x^2 - 2xy + y^210 # xy11 xy = np.matmul(x, np.transpose(y))12 # x^213 xx = np.matmul(x, np.transpose(x))14 xx = np.diag(xx)15 # y^216 yy = np.matmul(y, np.transpose(y))17 yy = np.diag(yy)18 '''19 (batch_size,1)-(batch_size,batch_size):20 Equivalent to each column operation21 (batch_size,batch_size)+(1,batch_size):22 Equivalent to each row operation23 '''24 distances = np.expand_dims(xx, 1) - 2.0*xy + np.expand_dims(yy, 0)25 return distances Mask這邊要注意Label需要使用shape=(batch_size,)的格式： 1def _label_mask(labels):2 '''3 if label is same, label_mask will return True4 ------------------------------------5 Args:6 labels: Label Data, shape = (batch_size,1)7 Returns:8 label_mask: tensor, with shape [m, n], (batch_size, batch_size)9 ex.10 labels = [1,0,1]11 label_mask = [[1, 0, 1],12 [0, 1, 0],13 [1, 0, 1]]14 '''15 label_mask = np.equal(np.expand_dims(labels, 0), np.expand_dims(labels, 1))16 return label_mask Triplet Loss (batch_all)這邊就是全部的流程，首先先算出兩個Embedding的dist_mat，再分別計算屬於anchor到positive的距離的mask和屬於anchor到negative的距離就可以分別得到dist_ap和dist_an，最後再計算dist_ap-dist_an+margin就得出triplet loss，具體計算過程如下： 1def batch_all(labels, emb1, emb2, margin):2 '''3 batch all triplet loss of a batch4 ------------------------------------5 Args:6 labels: Label Data, shape = (batch_size,1)7 emb1, emb2: Embedding Feature, shape = (batch_size, vector_size)8 margin: margin, scalar9 Returns:10 triplet_loss: scalar, for one batch11 '''12 dist_mat = _distance_metric(emb1, emb2)13 # an and ap mask14 ap_mask = _label_mask(labels)15 an_mask = np.logical_not(ap_mask).astype(np.float32)16 ap_mask = ap_mask.astype(np.float32)17 # distance between anchor and positive18 dist_ap = np.sum(dist_mat*ap_mask, axis=1)/np.sum(ap_mask, axis=1)19 # ap - dist_mat + margin20 mat = np.expand_dims(dist_ap, 1) - dist_mat + margin21 # only need ap-an22 mat = mat*an_mask23 # caluculate the number of valid triplet loss24 mask = np.greater(mat, 0.0).astype(np.float32)25 num_valid_triplets = np.sum(mask)26 triplet_loss = mat*mask27 # &lt;1 : 128 num_valid_triplets = np.maximum(num_valid_triplets, 1.0)29 # divided triplet_loss by num_valid_triplets30 triplet_loss = np.sum(triplet_loss)/(num_valid_triplets + 1e-16)31 return triplet_loss, num_valid_triplets Batch HardBatch Hard跟Batch All只差在算dist_ap時取最大的那一個，算dist_an找最小的那一個，另外也跟上面一樣計算num_valid_triplets，用來確認收斂程度： 1def batch_hard(labels, emb1, emb2, margin):2 '''3 batch all triplet loss of a batch4 ------------------------------------5 Args:6 labels: Label Data, shape = (batch_size,1)7 emb1, emb2: Embedding Feature, shape = (batch_size, vector_size)8 margin: margin, scalar9 Returns:10 triplet_loss: scalar, for one batch11 '''12 dist_mat = _distance_metric(emb1, emb2)13 # an and ap mask14 ap_mask = _label_mask(labels)15 an_mask = np.logical_not(ap_mask).astype(np.float32)16 ap_mask = ap_mask.astype(np.float32)17 # distance between anchor and positive18 dist_ap = np.sum(dist_mat*ap_mask, axis=1)/np.sum(ap_mask, axis=1)19 # ap - dist_mat + margin20 mat = np.expand_dims(dist_ap, 1) - dist_mat + margin21 # only need ap-an22 mat = mat*an_mask23 # caluculate the number of valid triplet loss24 mask = np.greater(mat, 0.0).astype(np.float32)25 num_valid_triplets = np.sum(mask)2627 # the max of distance between anchor and positive28 hardest_dist_ap = np.max(dist_mat*ap_mask, axis=1)29 # the max of distance between anchor and negative30 max_num = np.max(dist_mat, axis=1)31 hardest_dist_an = dist_mat*an_mask + ap_mask*max_num32 hardest_dist_an = np.amin(hardest_dist_an, axis=1)33 # ap - dist_mat + margin34 mat = hardest_dist_ap - hardest_dist_an + margin35 # &lt;1 : 136 triplet_loss = np.maximum(mat, 0.0)37 triplet_loss = np.mean(triplet_loss)38 return triplet_loss, num_valid_triplets Example接下來針對triplet_loss還有num_valid_triplet在訓練過程中的變化，另外還會對emb1和emb2算各項的平方和再開根號。 triplet_loss在訓練過程中triplet loss不會下降，因為這邊是計算valid triplet總和再除以需要計算的數量： num_valid_triplet這跟一般類神經網路的loss一樣，會越來越少： mean_norm_embedding因為類神經網路要區分開positive跟negative的例子，理論上會越來越大(如右圖)，不過我因為使用的image embedding是pretrain的，所以我先凍結image network 10個epoch，所以在圖表上他沒有太大的波幅： Code LinkTensorflow所有的code都是在Google Colab上面執行，版本為2.1.0。 Github：MachineLearning-01 Triplet Loss with Different Embedding 參考資料Triplet-Loss原理及其实现","link":"/2020/02/04/MachineLearning-01/"},{"title":"GAN系列-00 Generative Adversarial Network 生成對抗網路","text":"Generative Adversarial NetworkGenerative Adversarial Network(生成對抗網路，簡稱GAN)，算是這十年來最紅的技術，許多在機器學習領域的大佬都說：「GAN是這10年、20年來最酷、最有趣的想法。」，在網路上GAN的介紹文已經算是很氾濫了，這邊就簡單的介紹一下。 GAN是由Ian Goodfellow所在2014年所提出的方法，原本是作為非監督式學習(Unsupervised learning)使用，不過在這幾年的不斷使用，它也被證明對監督式學習、半監督式學習、強化學習是有幫助的。GAN常被用於： 風格轉換(Style Transfer)，這是一種在GAN裡面最被人所知的應用，泛指可以將一種類型圖像轉換到另一種類別．例如：將照片轉換成梵谷風格的圖畫、將線稿轉換成上好色的圖片、將圖片中的馬變成斑馬等等。 生成高解析度的圖像．透過GAN將原本低解析度的圖片變成高解析度的．這個常用於：將老電影修補、轉換成高解析度的、同理也能將遊戲中原本低解析度的紋理透過GAN生成更清晰的紋理圖像等等。 提供更多資料，透過GAN可以生成和和原始資料相似的圖片或是資料．因為這些生成的資料假以亂真，可以將這些資料作為訓練資料來加強原本訓練的網路。 還有許多應用，如在天文、醫學、時裝…等等，就不一一列舉了。 說了那麼多的應用，那GAN到底是什麼用了什麼概念讓它有這麼強大的能力呢？其實這個概念不難，就像是他本身名字所敘述的：對抗，GAN利用了兩個網路，分別是Generator跟Discriminator，來對抗彼此、精進本身，來達到目的。可以想像成偽造者跟鑑定家之間的比拼，以鈔票來舉例就是製造偽鈔者跟警察兩者的比拼，前者不斷製造假鈔來讓後者辨識，直到假鈔真假難辨為止。 GAN具體的架構如同標題上方的圖片，Generator生成虛假的例子交給Discriminator辨識，Discriminator再將辨識結果回饋給Generator，透過不斷的訓練，讓兩個網路越來越強大，Generator生成的圖片就會越來越像真的了。 各種GAN實作GAN經過這些年的發展有了許多的變體，來適應各種挑戰，這邊列舉了一些常見的GAN模型，將透過Tensorflow 2來實作： Generative Adversarial Network Conditional Generative Adversarial Nets Deep Convolutional Generative Adversarial Network WGAN WGAN-GP CycleGAN StarGAN IRGAN SeqGAN","link":"/2020/05/30/GAN-00/"}],"tags":[{"name":"ubuntu","slug":"ubuntu","link":"/tags/ubuntu/"},{"name":"ubuntu-18.04","slug":"ubuntu-18-04","link":"/tags/ubuntu-18-04/"},{"name":"xrdp","slug":"xrdp","link":"/tags/xrdp/"},{"name":"static ip","slug":"static-ip","link":"/tags/static-ip/"},{"name":"nvidia-gpu","slug":"nvidia-gpu","link":"/tags/nvidia-gpu/"},{"name":"docker","slug":"docker","link":"/tags/docker/"},{"name":"hexo","slug":"hexo","link":"/tags/hexo/"},{"name":"docker-19.03","slug":"docker-19-03","link":"/tags/docker-19-03/"},{"name":"nvidia-docker","slug":"nvidia-docker","link":"/tags/nvidia-docker/"},{"name":"native gpu","slug":"native-gpu","link":"/tags/native-gpu/"},{"name":"nvidia-container-toolkit","slug":"nvidia-container-toolkit","link":"/tags/nvidia-container-toolkit/"},{"name":"lvm","slug":"lvm","link":"/tags/lvm/"},{"name":"pv","slug":"pv","link":"/tags/pv/"},{"name":"vg","slug":"vg","link":"/tags/vg/"},{"name":"lv","slug":"lv","link":"/tags/lv/"},{"name":"Google Search Console","slug":"Google-Search-Console","link":"/tags/Google-Search-Console/"},{"name":"Google Analytics","slug":"Google-Analytics","link":"/tags/Google-Analytics/"},{"name":"sitemap","slug":"sitemap","link":"/tags/sitemap/"},{"name":"Dockerfile","slug":"Dockerfile","link":"/tags/Dockerfile/"},{"name":"portainer","slug":"portainer","link":"/tags/portainer/"},{"name":"anaconda","slug":"anaconda","link":"/tags/anaconda/"},{"name":"cuda","slug":"cuda","link":"/tags/cuda/"},{"name":"cudnn","slug":"cudnn","link":"/tags/cudnn/"},{"name":"Docker Hub","slug":"Docker-Hub","link":"/tags/Docker-Hub/"},{"name":"non-zero code 2","slug":"non-zero-code-2","link":"/tags/non-zero-code-2/"},{"name":"triplet loss","slug":"triplet-loss","link":"/tags/triplet-loss/"},{"name":"different embedding","slug":"different-embedding","link":"/tags/different-embedding/"},{"name":"tensorflow","slug":"tensorflow","link":"/tags/tensorflow/"},{"name":"numpy","slug":"numpy","link":"/tags/numpy/"},{"name":"GAN","slug":"GAN","link":"/tags/GAN/"},{"name":"Generative Adversarial Network","slug":"Generative-Adversarial-Network","link":"/tags/Generative-Adversarial-Network/"}],"categories":[{"name":"DL Machine","slug":"DL-Machine","link":"/categories/DL-Machine/"},{"name":"hexo","slug":"hexo","link":"/categories/hexo/"},{"name":"Machin Learning","slug":"Machin-Learning","link":"/categories/Machin-Learning/"},{"name":"GAN","slug":"GAN","link":"/categories/GAN/"}]}